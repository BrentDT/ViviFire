/*
 * ViviFire Programming Language
 *
 * Copyright 2025 Brent D. Thorn
 *
 * You can get the latest version at http://vivifire.com/.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file.
 */

#include <algorithm>
#include <array>
#include <assert.h>
#include <cstdio>
#include <cwctype>
#include <map>
#include <memory>
#include <stdexcept>
#include <string>
#include <time.h>
#include <vector>
#if defined(_WIN32)
#include <windows.h>
#endif
#include "Args.h"
#include "AST.h"
#include "Modifier.h"
struct Modif;
struct Modifiers;

#if __cplusplus >= 201703L // C++17
#include <filesystem>
#define S_PATH_SEP std::filesystem::path::preferred_separator
#elif defined(_WIN32)
#define S_PATH_SEP L"\\"
#else
#define S_PATH_SEP L"/"
#endif

// IMPORTANT: Use this macro with all productions.
// 'SyncNewline' gets passed 's_name'.
#define ID(sn, iv) \
	static const wchar_t *s_name = sn; \
	if (args.v >= Args::iv) wprintf(L">%ls", s_name);

extern Args args;

COMPILER ViviFire

static_assert(sizeof(time_t) == 8);

// The root of the AST. Memory is not freed automatically.
AST::Module *module = nullptr;

// Something to keep track of nested blocks.
std::vector<int> context;

// Used by `OptionalNewline` to compare where lines start.
int m_start_col = 0;

// Some enumeration types.
enum case_type { CASE_ZERO, CASE_EXPR, CASE_ELSE };
enum option_type { OPTION_DEFAULT, WITH_THEN, WITHOUT_THEN };
enum ternary { TERNARY0, TERNARY1, TERNARY2, YES = TERNARY1, NO = TERNARY2 };

// Aliases for 'true' and 'false'.
enum { POSTCONDITIONAL = 0, PRECONDITIONAL = 1 };

// Type aliases.
typedef std::map<std::wstring, int> when_map;
// Static inline variables.
static inline int s_MOD_line = 0, s_REM_line = 0, s_MODREM_col = 0; // For incorrectly used MOD and REM.

// Hold options for the directive '@OPTION'.
struct Option {
	Parser*     parser;
	enum class ByName { DEFAULT, Boolean, Literal };
	ByName     args_byname         = ByName::DEFAULT; // Arg ByName { Boolean | Literal }
	bool        args_enclosed      = false;    // Args Enclosed
	bool        charset_latin      = false;    // Charset Latin
	ternary     Dim_or_Var         = TERNARY0; // { Dim | Var }
	ternary     End_block          = TERNARY0; // End [ Block | No Block ]
	ternary     End_For_id         = TERNARY0; // End For [ ID | No ID ]
	bool        Enum_equals        = false;    // Enum Equals
	ternary     If_Then            = TERNARY0; // If [ Then | No Then ]
	bool        If_End             = false;    // If End
	bool        last               = false;    // Last
	bool        Mod_floored        = false;    // Mod Floored
	bool        New                = false;    // New
	bool        Optional_equals    = false;    // Optional Equals
	ternary     Select_Case        = TERNARY0; // Select [ Case | No Case ]
	enum class Strict { DEFAULT, Strict, String };
	Strict      Select_strict      = Strict::DEFAULT; // Select Strict [ String ]
	enum class Slash { DEFAULT, Fore, Back };
	Slash       String_slash       = Slash::DEFAULT; // String { Backslash | Slash }
	ternary     test_unit_or_comp  = TERNARY0; // Test [ Compiler ]
	enum class Each { DEFAULT, Each, Param, Var };
	Each        type_each          = Each::DEFAULT; // Type { Each | Param | Var }
	enum class EII { DEFAULT, Extends, Inherits, Is };
	EII         type_is            = EII::DEFAULT; // Type { Extends | Inherits | Is }
	bool        unit_full          = false;    // Unit Full
	short       warning            = 4;        // Warning[1-5]
	short       warning_error      = 0;        // Warning[1-5] Error
	ternary     When_Each_or_Else  = TERNARY0; // When { Each | Else }
	bool        When_id            = false;    // When ID

	bool match(const int kind) {
		if (kind != parser->la->kind) return false;
		parser->Get();
		return true;
	}

	bool match(const wchar_t *s) {
		return parser->Match(s);
	}

	bool left_match(const wchar_t *s) const {
		// Returns true if next token starts with s, then consumes it.
		std::unique_ptr<wchar_t> lcval(coco_string_create_lower(parser->la->val));
		if (parser->la->kind != _identifier || wcsstr(lcval.get(), s) != lcval.get()) return false;
		parser->Get();
		return true;
	}

	void option_error() const {
		parser->SemErr(L"Unknown or missing option");
	}

	void optional_no(int kind, const wchar_t *id = nullptr) const {
		// Test for optional "No" plus token.
		if (parser->Match(L"no")) {
			if (parser->la->kind == kind) {
				if (_identifier == kind) parser->Match(id);
				else parser->Get();
				return;
			}
			option_error();
		}
	}

	void Parse() {
		static const wchar_t *s_block = L"block", *s_equals = L"equals", *s_id = L"id", *s_warning = L"warning";
		int oldV = args.v; if (oldV < Args::EXPR) args.v = 0; // Silence subtokens.
		if (last) parser->SemErr(L"Cannot use @OPTION after @OPTION LAST");
		parser->Get();
		switch (parser->la->kind) {
		case _Dim:
			parser->Get();
			Dim_or_Var = TERNARY1;      // @Option Dim
			break;
		case _Var:
			parser->Get();
			Dim_or_Var = TERNARY2; // @Option Var
			break;
		case _End:
			parser->Get();
			if (match(_For)) { // End For
				if (match(s_id)) {
					End_For_id = YES; // @Option End For ID
					break;
				} else {
					optional_no(_identifier, s_id);
					End_For_id = NO; // @Option End For [ no id ]
					break;
				}
			} else if (match(s_block)) {
				End_block = YES; // @Option End Block
			} else {
				optional_no(_identifier, s_block);
				End_block = NO; // @Option End [ No Block ]
			}
			break;
		case _Enum:
			parser->Get();
			if (match(s_equals)) {
				Enum_equals = true; // @Option Enum Equals
			} else goto bad_option;
			break;
		case _If:
			parser->Get();
			if (match(_End)) {
				If_End = true; // @Option If End
			} else if (match(_Then)) {
				If_Then = YES;                    // @Option If Then
			} else {
				optional_no(_Then);
				If_Then = NO; // @Option If [ No Then ]
			}
			break;
		case _Mod:
			parser->Get();
			if (match(L"Floored")) {
				Mod_floored = true; // @Option Mod Floored
			} else goto bad_option;
			break;
		case _New:
			parser->Get();
			New = true; // @Option New
			break;
		case _Optional:
			parser->Get();
			if (match(s_equals)) {
				Optional_equals = true; // @Option Optional Equals
			} else goto bad_option;
			break;
		case _Select:
			parser->Get();
			if (match(L"strict")) {
				if (match(_String)) {
					Select_strict = Strict::String; // @Option Select Strict String
				} else {
					Select_strict = Strict::Strict; // @Option Select Strict
				}
			} else if (match(_Case)) {
				Select_Case = YES;                      // @Option Select Case
			} else {
				optional_no(_Case);
				Select_Case = NO; // @Option Select [ No Case ]
			}
			break;
		case _String:
			parser->Get();
			if (match(L"backslash")) {
				String_slash = Slash::Back; // @Option String Backslash
			}else if (match(L"slash")) {
				String_slash = Slash::Fore; // @Option String Slash
			} else goto bad_option;
			break;
		case _Unit:
			parser->Get();
			if (match(L"full")) {
				unit_full = true; // @Option Unit Full
			} else goto bad_option;
			break;
		case _When:
			parser->Get();
			if (match(_Each)) {
				When_Each_or_Else = TERNARY1; // @Option When Each
			} else if (match(_Else)) {
				When_Each_or_Else = TERNARY2; // @Option When Else
			} else if (match(s_id)) {
				When_id = true; // @Option When ID
			} else goto bad_option;
			break;
		case _identifier: {
			// For each addition, remember to "break" when correct.
			int len = coco_string_length(parser->la->val);
			if (4 == len && match(L"args")) {
				if (match(L"byname")) {
					if (match(_Boolean)) {
						args_byname = ByName::Boolean; // @Option Args ByName Boolean
						break;
					} else if (match(L"literal")) {
						args_byname = ByName::Literal; // @Option Args ByName Literal
						break;
					}
				} else if (match(L"enclosed")) {
					args_enclosed = true; // @Option Args Enclosed
					break;
				}
			} else if (7 == len && match(L"charset")) {
				if (!match(L"latin")) goto bad_option;
				charset_latin = true; // @Option Charset Latin
				// TODO: swap in a different scanner.
				break;
			}else if (4 == len && match(L"last")) {
				last = true; // @Option Last
				break;
			} else if (4 == len && match(L"test")) {
				if (match(L"compiler")) {
					test_unit_or_comp = TERNARY2; // @Option Test Compiler
				} else {
					test_unit_or_comp = TERNARY1; // @Option Test
				}
				break;
			} else if (4 == len && match(L"type")) {
				if (match(_Each)) {
					type_each = Each::Each; // @Option Type Each
					break;
				}else if (match(L"param")) {
					type_each = Each::Param; // @Option Type Param
					break;
				} else if (match(_Var)) {
					type_each = Each::Var; // @Option Type Var
					break;
				} else if (match(L"Extends")) {
					type_is = EII::Extends; // @Option Type Extends
					break;
				} else if (match(L"Inherits")) {
					type_is = EII::Inherits; // @Option Type Inherits
					break;
				} else if (match(_Is)) {
					type_is = EII::Is; // @Option Type Is
					break;
				} else goto bad_option;
			} else if (len >= 7 && left_match(s_warning)) {
				short level = (short)parser->t->val[coco_string_length(s_warning)]; // Valid: '\0', '1', '2', '3', '4', & '5'.
				if (level == 0) {
					level = L'4'; // Default is 4.
				} else if (level < L'1' || level > L'5') goto bad_option;
				level -= L'0';
				if (match(L"error")) {
					warning_error = level; // @Option Warning[1-5] Error
					break;
				} else {
					warning = level; // @Option Warning[1-5]
					break;
				}
			}
			// Fall through for error
		}
		default:
		bad_option:
			parser->Get();
			option_error();
			break;
		}
		if (parser->la->kind != _line_break && parser->la->kind != _EOF) goto bad_option;
		args.v = oldV;
	}

};

Option option = { /* parser */ this };

void Optional(int kind, option_type nOption = OPTION_DEFAULT) {
	// Parse elements that are usually optional, but can become mandatory by '@OPTION'.
	// Param 'nOption' can give more context.

	switch (kind) {
	case _Case:  // Select [ Case ]
		if (la->kind == _Case) {
			Get();
			if (option.Select_Case == NO) SemErr(L"Cannot use CASE after SELECT because of @OPTION");
		}
		else if (option.Select_Case == YES) SemErr(L"Must use SELECT CASE because of @OPTION");
		break;
	case _Class:        // End [ Class ]
	case _Constructor:  // End [ Constructor ]
	case _Declare:      // End [ Declare ]
	case _Destructor:   // End [ Destructor ]
	case _Enum:         // End [ Enum ]
	case _Function:     // End [ Function ]
	case _If:           // End [ If ]
	case _Method:       // End [ Method ]
	case _Object:       // End [ Object ]
	case _Property:     // End [ Property ]
	case _Select:       // End [ Select ]
	case _Struct:       // End [ Struct ]
	case _Sub:          // End [ Sub ]
	case _Trait:        // End [ Trait ]
	case _Try:          // End [ Try ]
	case _Unit:         // End [ Unit ]
	case _While:  // End [ While ]
		if (la->kind == _line_break) { // END without block type.
			if (option.End_block == YES) SemErr(L"END must have block type because of @OPTION");
		} else { // END with block type.
			if (option.End_block == NO) {
				Get();
				SemErr(L"END cannot have block type because of @OPTION");
			} else if (la->kind != kind) { // Incorrect block type.
				Expect(kind);
			} else {
				Get();
			}
		}
		break;
	case _For:  // End [ For [ name ] ]
		if (la->kind == _For) {
			Get();
			if (option.End_block == NO) SemErr(L"END cannot have block type because of @OPTION");
			if (IsIdentifier(la->kind)) {
				Name();
				if (option.End_For_id == NO) SemErr(L"END FOR cannot have name because of @OPTION");
			}
			else if (option.End_For_id == YES) SemErr(L"END FOR must have name because of @OPTION");
		}
		//TODO: else if (end_block)
		break;
	case _Then:
		if (nOption == OPTION_DEFAULT && la->kind == _Then) {
			nOption = WITH_THEN;
			Get();
		}
		if (nOption == WITH_THEN && option.If_Then == NO)
			SemErr(L"IF cannot have THEN because of @OPTION");
		else if (nOption == WITHOUT_THEN && option.If_Then == YES)
			SemErr(L"IF must have THEN because of @OPTION");
		break;
	default:
		#if defined(DEBUG)
		errors->Exception(L"Bad kind in Optional");
		#endif
		break;
	}
}

class param_validator {
	Parser *m_parser;
	int m_parent;
		// _typed_identifier => PROPERTY SELF!name[%@!$]
		// _Set => PROPERTY ... SET
	int m_count = 0;
	bool m_byref = false;
	int m_optionals = 0;

public:
	param_validator(Parser *parser, int parent): m_parser(parser), m_parent(parent) {}

	void Add(int modif = 0) {
	assert(0 == modif || _ByRef == modif || _Optional == modif);

		m_count++;

		if (2 == m_count) {
			// Check if parent construct must have one param.
			dictionary_1_param() || Set_1_param();
		}

		switch (modif) {
		case 0:
			m_byref = false;  // by value
			break;
		case _ByRef:
			if (m_optionals) m_parser->SemErr(L"Cannot use BYREF with OPTIONAL");
			else m_byref = true;
			break;
		case _Optional:
			if (m_optionals == 1) m_parser->Warn(L"OPTIONAL is not necessary again");
			else m_optionals++;
			break;
		}
	}

	void None() const {
		// Check if parent construct must have one param.
		dictionary_1_param() || Set_1_param();
	}

	bool Optional() const { return (m_optionals != 0); }

private:
	bool dictionary_1_param() const {
		if (_typed_identifier != m_parent) return false;
		m_parser->SemErr(L"Dictionary-access property must have one parameter");
		return true;
	}
	bool Set_1_param() const {
		if (_Set != m_parent) return false;
		m_parser->SemErr(L"SET must have one parameter");
		return true;
	}
};

struct property_sig {
	int line, col;
	bool dict_access = false;
};

bool Match(const wchar_t *s) {
	// Returns true if the next token is the same as s, then consumes it.
	assert(s != nullptr);
	if (la->kind != _identifier || _wcsicmp(s, la->val) != 0) return false;
	Get();
	return true;
}

bool Matches(const wchar_t *s) {
	// Returns true if the current token is the same as s.
	assert(s != nullptr);
	return (_wcsicmp(s, t->val) == 0);
}

std::string wchar_to_UTF8(wchar_t in) {
	// Adapted from <https://stackoverflow.com/questions/148403>.
	std::string out;
	unsigned int codepoint = 0;
	if (in >= 0xd800 && in <= 0xdbff) {
		codepoint = ((in - 0xd800) << 10) + 0x10000;
	} else {
		if (in >= 0xdc00 && in <= 0xdfff)
			codepoint |= in - 0xdc00;
		else
			codepoint = in;

		if (codepoint <= 0x7f) {
			out.append(1, static_cast<char>(codepoint));
		} else if (codepoint <= 0x7ff) {
			out.append(1, static_cast<char>(0xc0 | ((codepoint >> 6) & 0x1f)));
			out.append(1, static_cast<char>(0x80 | (codepoint & 0x3f)));
		} else if (codepoint <= 0xffff) {
			out.append(1, static_cast<char>(0xe0 | ((codepoint >> 12) & 0x0f)));
			out.append(1, static_cast<char>(0x80 | ((codepoint >> 6) & 0x3f)));
			out.append(1, static_cast<char>(0x80 | (codepoint & 0x3f)));
		} else {
			out.append(1, static_cast<char>(0xf0 | ((codepoint >> 18) & 0x07)));
			out.append(1, static_cast<char>(0x80 | ((codepoint >> 12) & 0x3f)));
			out.append(1, static_cast<char>(0x80 | ((codepoint >> 6) & 0x3f)));
			out.append(1, static_cast<char>(0x80 | (codepoint & 0x3f)));
		}
	}
	return out;
}

std::wstring StringValue(wchar_t *pStrToken) {
	// Returns the string value of a string literal or constant.
	assert(pStrToken != nullptr);
	assert(pStrToken[0] == L'"' || pStrToken[0] == L'_' || pStrToken[0] == L'$');

	wchar_t *pStart = &pStrToken[(*pStrToken == L'_') ? 1 : 0]; // Ignore underscore.
	bool interpolated = false;

	// Quoted string literal.
	if ( (*pStart == L'"')
	|| (interpolated = (pStart[0] == L'$' && pStart[1] == L'"')) ) {
		std::wstring res;

		// Remove '$' and unnecessary quotes.
		if (!interpolated) {
			// Usual string (eg "Hello, world!").
			for (wchar_t *pChar = pStart + 1; *pChar; pChar++) {
				if (*pChar != L'"') res += *pChar;
				else if (pChar[1] == L'"') res += *pChar++; // Two quotes become one.
				// End quote is skipped automatically.
			}
		} else {
			// Interpolated string (eg $"Hello, {name}!").
			std::string tempStr{'\xEF', '\xBB', '\xBF'}; // Initialized with UTF-8 BOM.
			int nBraces = 0;
			context.push_back(_string_literal);

			for (wchar_t *pChar = pStart + 2; *pChar; pChar++) {
				switch (*pChar) {
				case L'{': 
					if (pChar[1] == L'{') pChar++; // Two braces become one.
					else if (++nBraces == 1) pStart = pChar + 1; // Start of interpolated expression.
					else if (nBraces > 0) tempStr += '{'; // Interpolation includes a brace.
					if (nBraces == 0) res += *pChar;
					break;
				case L'"':
					if (pChar[1] == L'"' || pChar[1] == L'\0') pChar++; // Two quotes become one.
					if (nBraces > 0) tempStr += '"'; // Interpolation includes a quote.
					else if (nBraces == 0) res += *pChar;
					break;
				case L'}':
					if (pChar[1] == L'}') pChar++; // Two braces become one.
					if (nBraces == 0) res += *pChar;
					else if (--nBraces == 0) {
						// Parse the interpolated expression.
						tempStr += '}'; // Use in place of EOF.
						std::unique_ptr<Scanner> tempScanner(new Scanner((unsigned char *) tempStr.c_str(), tempStr.length()));
						std::unique_ptr<Parser> tempParser(new Parser(tempScanner.get()));

						tempParser->ParseInterpolated(this, pStart - pStrToken);

						tempStr.clear();
					} else if (nBraces > 0) tempStr += '}'; // Interpolation includes a brace.
					break;
				default:
					if (nBraces > 0) tempStr += wchar_to_UTF8(*pChar);
					else res += *pChar;
					break;
				} // switch
			} // for

			context.pop_back();
			if (nBraces > 0) SemErr(L"More left braces than right");
			else if (nBraces < 0) SemErr(L"More right braces than left");
		} // if

		return res;
	} else if (*pStrToken == L'$') { // String constant.
		// Handle character codes. Make sure to return if valid.
		// Named constants are handled after these.
		switch (pStrToken[1]) {
		case L'B': case L'b': { // Binary $B...
			std::wstring ws;
			for (wchar_t *pChar = pStrToken + 2; *pChar; pChar++) {
				if (*pChar == L'0' || *pChar == L'1') ws += *pChar;
				else if (*pChar == L'_'); // Ignore underscore.
				else goto named_constant;
			}
			int ch = std::stoi(ws, nullptr, 2);
			if (ch > WCHAR_MAX) throw new std::out_of_range("Character code out of range");
			std::wstring res(1, (wchar_t)ch);
			return res;
		}
		case L'O': case L'o': { // Octal $O...
			std::wstring ws;
			for (wchar_t *pChar = pStrToken + 2; *pChar; pChar++) {
				if (*pChar >= L'0' && *pChar <= L'7') ws += *pChar;
				else if (*pChar == L'_'); // Ignore underscore.
				else goto named_constant;
			}
			int ch = std::stoi(ws, nullptr, 8);
			if (ch > WCHAR_MAX) throw new std::out_of_range("Character code out of range");
			std::wstring res(1, (wchar_t)ch);
			return res;
		}
		case L'U': case L'u': case L'X': case L'x': { // Hexadecimal $U... or $X...
			std::wstring ws;
			for (wchar_t *pChar = pStrToken + 2; *pChar; pChar++) {
				if (*pChar >= L'0' && *pChar <= L'9' || *pChar >= L'A' && *pChar <= L'F' || *pChar >= L'a' && *pChar <= L'f') ws += *pChar;
				else if (*pChar == L'_'); // Ignore underscore.
				else goto named_constant;
			}
			int ch = std::stoi(ws, nullptr, 16);
			if (ch > WCHAR_MAX) throw new std::out_of_range("Character code out of range");
			std::wstring res(1, (wchar_t)ch);
			return res;
		}
		default:
		if (pStrToken[1] >= L'0' && pStrToken[1] <= L'9') {
			std::wstring ws;
			for (wchar_t *pChar = pStrToken + 1; *pChar; pChar++) {
				if (*pChar >= L'0' && *pChar <= L'9') ws += *pChar;
				else if (*pChar == L'_'); // Ignore underscore.
				else goto named_constant;
			}
			int ch = std::stoi(ws, nullptr, 10);
			if (ch > WCHAR_MAX) throw new std::out_of_range("Character code out of range");
			std::wstring res(1, (wchar_t)ch);
			return res;
		}
		named_constant:
			return NamedString(pStrToken);
		}
	}
	return std::wstring(L"ERR"); // TEMP
}

enum datetime_fmt {
	INVALID_FMT,
	DATE, DATE_DMY, DATE_MDY, DATE_YMD,
	TIME, TIME_12HM, TIME_12HMS, TIME_24HM, TIME_24HMS
};

std::wstring NamedString(wchar_t *s) {
	assert(s != nullptr);
	assert(s[0] == L'$' && s[1] != L'\0');

	s++; // Skip '$'.

	switch (s[0]) {
	case L'C': case L'c':
		if (!_wcsicmp(L"CR", s))
			return std::wstring(L"\r");
		break;
	case L'D': case L'd':
		if (!_wcsnicmp(L"DATE", s, 4)) {
			s += 4;
			if (s[0] != L'\0' && s[0] != L'_') goto bad_name;

			//TODO: $DATE $DATE_DMY $DATE_MDY $DATE_YMD
		}
		break;
	case L'E': case L'e':
		if (s[1] == L'\0' || !_wcsicmp(L"ESC", s) || !_wcsicmp(L"ESCAPE", s))
			return std::wstring(L"\033");
		break;
	case L'F': case L'f':
		if (!_wcsicmp(L"FF", s) || !_wcsicmp(L"FORMFEED", s))
			return std::wstring(L"\f");
		else if (!_wcsicmp(L"FILE", s)) {
			//FIXME: does not work for libraries
			wchar_t *ws = coco_string_create(args.file);
			std::wstring res(ws);
			delete ws;
			return res;
		}
		break;
	case L'L': case L'l':
		if (!_wcsicmp(L"LF", s) || !_wcsicmp(L"LINEFEED", s))
			return std::wstring(L"\013");
		else if (!_wcsicmp(L"LINE", s))
			return std::to_wstring(t->line);
		break;
	case L'N': case L'n':
		if (s[1] == L'\0' || !_wcsicmp(L"NL", s) || !_wcsicmp(L"NEWLINE", s))
			#if defined(_WIN32)
			return std::wstring(L"\r\n");
			#else
			return std::wstring(L"\015");
			#endif
		break;
	case L'P': case L'p':
		if (!_wcsicmp(L"PD", s) || !_wcsicmp(L"PARENTDIR", s))
			return std::wstring(L"..");
		else if (!_wcsicmp(L"PS", s) || !_wcsicmp(L"PATHSEP", s))
			return std::wstring(S_PATH_SEP);
		break;
	case L'R': case L'r':
		if (s[1] == L'\0' || !_wcsicmp(L"RETURN", s))
			return std::wstring(L"\r");
		//TODO: RD/ROOTDIR
		break;
	case L'S': case L's':
		if (s[1] == L'\0' || !_wcsicmp(L"SPC", s) || !_wcsicmp(L"SPACE", s))
			return std::wstring(L" ");
		break;
	case L'T': case L't':
		if (s[1] == L'\0' || !_wcsicmp(L"TAB", s))
			return std::wstring(L"\t");
		else if (!_wcsnicmp(L"TIME", s, 4)) {
			s += 4;
			if (s[0] != L'\0' && s[0] != L'_') goto bad_name;

			struct tm utc; time_t now;
			time(&now);
			gmtime_s(&utc, &now);

			std::wstring secs;

			if (s[0] == L'\0') { // $TIME
				//TODO
			} else if (!_wcsicmp(L"_12HM", s)) { // $TIME_12HM
				secs += (utc.tm_hour < 12) ? L" AM": L" PM";
				if (utc.tm_hour > 12) utc.tm_hour -= 12;
				else if (utc.tm_hour == 0) utc.tm_hour = 12;
			} else if (!_wcsicmp(L"_12HMS", s)) { // $TIME_12HMS
				secs += L':';
				if (utc.tm_sec < 10) secs += L'0';
				secs += std::to_wstring(utc.tm_sec);
				secs += (utc.tm_hour < 12) ? L" AM": L" PM";
				if (utc.tm_hour > 12) utc.tm_hour -= 12;
				else if (utc.tm_hour == 0) utc.tm_hour = 12;
			} else if (!_wcsicmp(L"_24HM", s)) { // $TIME_24HM
				// Nothing to do.
			} else if (!_wcsicmp(L"_24HMS", s)) { // $TIME_24HMS
				secs += L':';
				if (utc.tm_sec < 10) secs += L'0';
				secs += std::to_wstring(utc.tm_sec);
			} else goto bad_name;

			wchar_t ws[16];
			swprintf_s(ws, 15, L"%02d:%02d%ls", utc.tm_hour, utc.tm_min, secs.c_str());
			std::wstring res(ws);
			return res;
		}
	}
	bad_name:
	return std::wstring(L"ERR"); //TEMP
}

void Err(const wchar_t *msg) {
	errors->Error(t->line, t->col, msg);
}

void Err(int line, int col, const wchar_t *msg) {
	errors->Error(line, col, msg);
}

void Warn(const wchar_t *msg) {
	// TODO: warning levels.
	if (option.warning_error) Err(msg);
	else errors->Warning(msg);
}

void Warn(int line, int col, const wchar_t *msg) {
	// TODO: warning levels.
	if (option.warning_error) Err(line, col, msg);
	else errors->Warning(line, col, msg);
}

#define COUNT_MOD_AND_REM(op, other) \
	void Count_##op() { \
		if (s_##op##_line) return; \
		s_##op##_line = t->line + errors->LineDelta(); /* Get physical line. */ \
		if (0 == s_##other##_line) { \
			s_MODREM_col = t->col + errors->ColDelta(); /* Get physical column. */ \
		} else if (!option.Mod_floored) { /* Without @OPTION MOD FLOORED. */ \
			Warn(s_##other##_line - errors->LineDelta(), s_MODREM_col - errors->ColDelta(), \
				L"You used " #other L" here..."); \
			Warn(t->line, t->col, \
				L"And you used " #op L" here, although they are the same operation." \
				L" Possibly you want the directive @OPTION MOD FLOORED?" \
			); \
			s_MOD_line = s_REM_line = -1; /* Prevent more warnings. */ \
		} \
	}

COUNT_MOD_AND_REM(MOD, REM)
COUNT_MOD_AND_REM(REM, MOD)
#undef COUNT_MOD_AND_REM

inline bool in_context(int kind) {
	return (std::find(context.rbegin(), context.rend(), kind) != context.rend());
}

void ParseInlineComment() {
	// Parse out "expect-error {{msg}}" or "expect-warning {{msg}}".
	wchar_t *p = la->val;

		// Move past "'" or "//", and whitespace.
	while (*p == L'/' || *p == L'\'' || *p == 32 || *p == 9 || *p == 160) p++;

	// Find "expect-".
	if (wcsncmp(p, L"expect-", 7)) return;
	p += 7;

	// Find "error" or "warning".
	bool bError = true;
	if (wcsncmp(p, L"error", 5) == 0) {
		p += 5;
	} else if (wcsncmp(p, L"warning", 7) == 0) {
		p += 7; bError = false;
	} else return;

	// Whitespace again.
	while (*p == 32 || *p == 9 || *p == 160) p++;

	// Find "{{".
	if (p[0] != L'{' && p[1] != L'{') return; // FIXME: Should this be an error?
	p += 2;

	// Find "}}".
	wchar_t *pRight = wcsstr(p, L"}}");
	if (pRight == nullptr) return; // FIXME: Should this be an error?

	if (bError) {
		Warn(L"Expecting an error"); // TEMP
	} else {
		Warn(L"Expecting a warning"); // TEMP
	}
}

///const wchar_t *SIGILS = L"%!$@";

// Resolvers

bool IsAssignmentOp() {
	switch (la->kind) {
	case _concatenation: case _plus: case _minus: case _asterisk: case _slash: case _backslash:
	case _Div: case _Mod: case _Rem: case _SHL: case _SHR: case _And: case _Or: case _Xor:
		if (scanner->Peek()->kind != _equals) return false;
	case _equals: case _colon_equals:
		return true;
	}
	return false;
}

///bool IsCall() {
///	// Disambiguate "("[args]")" from "("["Is"]("<"|"<="|">"|">="|"<>"|"=")")".
///	if (la->kind == _left_paren) {
///		int first = scanner->Peek()->kind;
///		if (first == _Is || (first >= _less_than && first <= _equals)) return false;
///		return true;
///	}
///	return false;
///}

bool IsDateTime() {
	if (_time_literal == la->kind) return true;
	if (_integer_literal == la->kind && la->val[0] != L'%') { // Decimal literal.
		int sep = scanner->Peek()->kind;
		if (sep != _slash && sep != _minus) return false;
		if (_integer_literal == scanner->Peek()->kind && sep == scanner->Peek()->kind && _integer_literal == scanner->Peek()->kind) {
			return true;
		}
	}
	scanner->ResetPeek();
	return false;
}

bool IsDeclareParameterList() {
	if (_left_paren == la->kind) {
		int kind = scanner->Peek()->kind;
		if (_line_break == kind) kind = scanner->Peek()->kind;
		if (_Optional == kind) kind = scanner->Peek()->kind;
		if (_integer_literal == kind) return true;
	}
	scanner->ResetPeek();
	return false;
}

bool IsFixedPointArgument() {
	return (la->kind == _left_paren && scanner->Peek()->kind == _integer_literal);
}

bool IsIdentifier(int kind) {
	return (kind == _identifier || kind == _typed_identifier || kind == _hash);
}

bool IsEnumBaseType(int kind) {
	switch (kind) {
	case _identifier:
	case _Char: case _String:
	case _Fixed64: case _Fixed128:
	case _Real32: case _Real64: case _Real128:
	case _Int8: case _Int16: case _Int32: case _Int64: case _Int128:
	case _UInt8: case _UInt16: case _UInt32: case _UInt64: case _UInt128:
		return true;
	}
	return false;
}

bool IsNamedArgument() {
	if (!IsIdentifier(la->kind)) return false;

	int next = scanner->Peek()->kind;
	if (_hash == la->kind) next = scanner->Peek()->kind;

	if (_equals == next) {
		// TODO: Set a flag on the AST and subsequently do more tests than is possible here.
		Warn(t->line, t->col, 
		    L"The argument does an unusual test for equality (=). Possibly you want a named argument (:=).");
		scanner->ResetPeek();
		return false;
	}
	scanner->ResetPeek();
	return (_colon_equals == next);
}

bool IsPropertyWithParam() {
	if (IsIdentifier(la->kind) && scanner->Peek()->kind == _left_paren && IsIdentifier(scanner->Peek()->kind)) {
		return true;
	}
	scanner->ResetPeek();
	return false;
	// FIXME: Possible param modifier?
}

bool IsUnit() {
	if (la->kind == _identifier) return true;
	if (la->kind == _left_paren && scanner->Peek()->kind == _identifier) return true;
	return false;
}

bool IsUnorderedInit() {
	int k = la->kind;
	return ((k == _char_literal || k == _integer_constant || k == _integer_literal) && scanner->Peek()->kind == _colon_equals);
}

inline bool HasWhitespace() {
	// Is true if there is something between current and next tokens.
	return la->charPos > t->charPos + coco_string_length(t->val);
}

inline bool HasWhitespace(int tlength) {
	// Overloaded method used when length of t is known.
	return la->charPos > t->charPos + tlength;
}

void ParseInterpolated(Parser *parseRoot, int col_offset) {
	// Partial duplicate of `Parser::Parse()`.
	t = NULL;
	la = dummyToken = new Token();
	la->val = coco_string_create(L"Dummy Token");
	errors->SetDelta(parseRoot->t->line, parseRoot->t->col + col_offset);
	Get();

	TolExpression();
	Expect(_right_brace);

	parseRoot->errors->count += errors->count;
}

inline void BlockBody(int kind, int line, int col, wchar_t *msg) {
	BlockBody(kind, line, col, msg, true);
}

IGNORECASE

CHARACTERS

// Single characters

n = '\n'.
r = '\r'.
t = '\t'.

// Character sets

ctrl = '\u0000' .. '\u001f'.
ws = ctrl + '\u0020' + '\u00a0'.
eol = n + r + /*VT*/ '\u000b' + /*FF*/ '\u000c' + /*LS*/ '\u2028' + /*PS*/ '\u2029'.
notEOL = ANY - ctrl - eol.

alpha = 'A' .. 'Z' + '\u00b5' /*Greek micro*/ + '\u03bc' /*Greek mu*/.
alnum = alpha + '0' .. '9'.
alNotX = alpha - 'X'.
alNotHex = alpha - "ABCDEF".
sigil = "!$%@".

bin = "01".
dec = '0' .. '9'.
hex = '0' .. '9' + 'A' .. 'F'.
oct = '0' .. '7'.

nonbin = alnum - bin.
nonhex = alnum - hex.
nonoct = alnum - oct.

currency = ANY - alnum - "_" - ws.

str = ANY - ctrl - eol - '"'.
notAfterStr = ANY - eol - " $&')+,./;<=>@\\_}". // Chars that cannot come after the closing quote.
char = ANY - ctrl - eol.

TOKENS

line_break  = eol{eol}.

at_sign     = "@".
comma       = ",".
dot         = ".".
exclamation = "!".
question    =  "?".
semicolon   = ";".

// Primary
left_paren    = "(".
right_paren   = ")".
left_bracket  = "[".
right_bracket = "]".
left_brace    = "{".
right_brace   = "}".

// Unary
plus  = "+".
minus = "-".

// Arithmetic
caret     = "^".
asterisk  = "*".
slash     = "/".
backslash = "\\".

// Concatenation
concatenation = "&".

// Null coalescing
null_coalescing = "??".

// Comparison
tilde            = "~".
less_than        = "<".
less_or_equal    = "<=".
greater_than     = ">".
greater_or_equal = ">=".
not_equal        = "<>".
equals           = "=".

// Assignment
colon_equals = ":=".

// Literals

char_literal =
	'`'char'`'.

malformed_char_literal =
	'`'[char{alnum}].

fixed_literal = ( '\u00a4' /*currency sign*/ | "@" currency ).

integer_constant =
	( "%"alNotX alpha{["_"]alnum}
	| "%X"alNotHex{["_"]alnum}
	).

integer_literal =
	( "%B"["_"]bin{["_"]bin}
	| "%O"["_"]oct{["_"]oct}
	| "%X"["_"]hex{["_"]hex}
		["_" CONTEXT ("i"|"u")]
	| dec{['_']dec}
	// Prevent misparsing units (eg "312electronvolts") as real_literal.
	| dec{['_']dec} CONTEXT ("E"alpha)
	).

malformed_integer_literal =
	( "%"
	| "%B"[(bin|"_"){bin|"_"}(nonbin|"_"){nonbin|"_"}]
	| "%O"[(oct|"_"){oct|"_"}(nonoct|"_"){nonoct|"_"}]
	| "%X"[(hex|"_"){hex|"_"}"_"]
	| dec{dec|"_"}"_"
	).

null_literal =
	'|'{'-'}.

real_literal =
	( [dec{['_']dec}]'.'dec{['_']dec}['E'['+'|'-']dec{dec}]['!']
	| dec{['_']dec}'E'['+'|'-']dec{dec}['!']
	| dec{['_']dec}'!'
	).

malformed_real_literal =
	( dec{dec|'_'}"__"{dec|'_'}'.'{'.'}{dec|'_'}['E'['+'|'-']{dec}]['!']
	| {dec|'_'}'.'{'.'}dec{dec|'_'}"__"{dec|'_'}['E'['+'|'-']{dec}]['!']
	| dec{dec|'_'}"__"{dec|'_'}'!'
	).

string_constant =
	'$'alnum{['_']alnum}.

string_literal =
	["_"]          // continuation
	["$"]          // interpolated string (eg $"Hello {name}!")
	'"'{str}'"'    // usual string
	{'"'{str}'"'}  // double quotes
	.

malformed_string_literal =
	["_"]["$"]
	( '"'{str}{'"''"'{str}}
	| '"'{str}'"'    // usual string
	  {'"'{str}'"'}  // double quotes
	  notAfterStr{str}
	).

time_literal =
	dec{dec}":"dec{dec}[":"dec{dec}["."dec{dec}]].

//TODO: malformed_time_literal

version_literal =
	dec{dec}"."dec{dec}"."dec{dec}["."dec{dec}].

//TODO: malformed_version_literal

// Identifiers

identifier =
	( alpha{["_"]alnum}
	// Use keywords, eg `Class`
	| "`"alpha alnum{alnum}"`"
	// Prevent misparsing "@modif@modif" & "obj!name" as typed_identifier.
	| alpha{["_"]alnum} CONTEXT (("!"|"@")alpha)
	).

typed_identifier =
	alpha{["_"]alnum}sigil.

// Keep `hash` after `identifier`, because it can have an effect on performance.
hash = "#".

// Keywords

And         = "And".
As          = "As".
Base        = "Base".
Begin       = "Begin".
Boolean     = "Boolean".
ByRef       = "ByRef".
Call        = "Call".
Case        = "Case".
Catch       = "Catch".
Char        = "Char".
Class       = "Class".
Const       = "Const".
Constructor = "Constructor".
DateTime        = "DateTime".
Declare     = "Declare".
Destructor  = "Destructor".
Dim         = "Dim".
Div         = "Div".
Do          = "Do".
Does        = "Does".
Each        = "Each".
Else        = "Else".
End         = "End".
Enum        = "Enum".
Event       = "Event".
Exit        = "Exit".
Finally     = "Finally".
Fixed64     = "Fixed64".
Fixed128    = "Fixed128".
For         = "For".
Function    = "Function".
Get         = "Get".
GoTo        = "GoTo".
Handles     = "Handles".
If          = "If".
In          = "In".
Int8        = "Int8".
Int16       = "Int16".
Int32       = "Int32".
Int64       = "Int64".
Int128      = "Int128".
Is          = "Is".
Let         = "Let".
Library     = "Library".
Loop        = "Loop".
Method      = "Method".
Mod         = "Mod".
///Namespace   = "Namespace".
New         = "New".
Not         = "Not".
Object      = "Object".
Optional    = "Optional".
Or          = "Or".
Out         = "Out".
Program     = "Program".
Property    = "Property".
Raise       = "Raise".
Real32      = "Real32".
Real64      = "Real64".
Real128     = "Real128".
ReDim       = "ReDim".
Rem         = "Rem".
Require     = "Require".
Return      = "Return".
SafeString  = "SafeString".
SBits       = "SBits".
Select      = "Select".
Self        = "Self".
Set         = "Set".
SHL         = "SHL".
SHR         = "SHR".
Step        = "Step".
String      = "String".
Struct      = "Struct".
Sub         = "Sub".
Then        = "Then".
To          = "To".
Tol         = "Tol".
Trait       = "Trait".
Try         = "Try".
UBits       = "UBits".
UInt8       = "UInt8".
UInt16      = "UInt16".
UInt32      = "UInt32".
UInt64      = "UInt64".
UInt128     = "UInt128".
Unit        = "Unit".
Until       = "Until".
Var         = "Var".
When        = "When".
Where       = "Where".
While       = "While".
Xor         = "Xor".
Yield       = "Yield".

PRAGMAS

bad_identifier = '\u00ce'. (.
	Get(); SemErr(L"Invalid name caused by incorrect file encoding. Write the file again as \"UTF-8 with BOM\"."); .)

LineContinuation = "_". (.
	Get();
	if (la->kind != _line_break && la->kind != _InlineComment)
	    Err(la->line, la->col, L"Newline or inline comment must follow line continuation"); .)

// Directives

atOption = "@Option". (. option.Parse(); .) //{notEOL}. //TODO
atError  = "@Error"{notEOL}. //TODO
atWarn   = "@Warn"{notEOL}. //TODO

// Comments

InlineComment = ("'"|"//"){notEOL}. (.
	if (option.test_unit_or_comp == TERNARY2) ParseInlineComment();
	// Warn when a comment after line continuation shows almost the same as an expression.
	// `variable = 'comment
	// expression`
	if ( (L'\'' == la->val[0])
	&& (_equals == t->kind || _comma == t->kind || _left_paren == t->kind || _left_brace == t->kind)
	) {
		Warn(la->line, la->col, 
			L"Line continuation without the _ then a comment with the ' is not easy to read. "
			L"We recommend that you use (1) the underscore or (2) the comment that starts  //..."
		);
	} .)

///MidlineComment = "/'"{"#"|alnum|"_"|"."|"-"|"/"|":"|sigil}"'/".

IGNORE t + '\u00a0' // non-breaking space

PRODUCTIONS

ViviFire (. ID(L"ViviFire", STMT) .)
=
	Module

	// Catch errors in block statements.
	[
		"Begin" (. SemErr(L"BEGIN without NEW or WHEN"); .)
	|
		"Case" (. SemErr(L"CASE without SELECT"); .)
	|
		"Catch" (. SemErr(L"CATCH without TRY"); .)
	|
		"Get" (. SemErr(L"GET without PROPERTY"); .)
	|
		"Else" (. SemErr(L"ELSE without IF"); .)
	|
		"End" (. SemErr(L"END without block. Possibly you want EXIT PROGRAM."); .)
	|
		"Finally" (. SemErr(L"FINALLY without TRY"); .)
	|
		"Loop" (. SemErr(L"LOOP without DO"); .)
	|
		"Rem" (. SemErr(L"REM is not a comment. Possibly you want ' or //"); .)
	|
		"Require" (. SemErr(L"REQUIRE must be before statements"); .)
	|
		"Set" (. SemErr(L"SET without PROPERTY"); .)
	|
		"Then" (. SemErr(L"THEN without IF"); .)
	|
		"Until" (. SemErr(L"UNTIL without DO or LOOP"); .)
	|
		"When" (. SemErr(L"WHEN without EXIT WHEN or UNIT"); .)
	|
		"Where" (. SemErr(L"WHERE is not permitted here"); .)
	|
		ConstantValueError
	]

	EOF

	(. wprintf(L"\n-- %d %ls\n", errors->count, (errors->count == 1) ? L"error" : L"errors"); .)
.

/*A*/
AdditiveExpression (. ID(L"Additive", EXPR) .)
=
	MultiplicativeExpression { ( '+' | '-' ) MultiplicativeExpression }
.
Argument (. ID(L"Argument", STMT) .)
=
	[ IF (IsNamedArgument())
		Name ":="
	]
	(
		null_literal
	|
		EnclosedExpression
	|
		LambdaExpression
	)
.
ArgumentList (. ID(L"ArgumentList", STMT) .)
=
	// Related: `OptionalArgList`.

	// Disambiguate `( args )` and `( expr )`.
	// Given a `(`, think it an enclosed argument list unless followed by `If`.
	( IF (_left_paren == la->kind && scanner->Peek()->kind != _If)
		EnclosedArgumentList
	|
		UnenclosedArgumentList<nullptr>
	)
.
AssignmentStatement (. ID(L"AssignmentStatement", STMT) .)
=
	(
		[
			( concatenation | "+" | "-" | "*" | "/" | "\\" | "Div" | "Mod" | "Rem" | "SHL" | "SHR" | "And" | "Or" | "Xor" )
			(. if (HasWhitespace()) Err(L"Bad assignment operator"); .)
		]
		"=" [OptionalNewline]
		Expression
	|
		":=" [OptionalNewline]
		Expression
		{
			":=" [OptionalNewline]
			Expression
		}
	)
.
AsTypeClause (. ID(L"AsTypeClause", STMT) .)
=
	"As"
	( UserType [ EnclosedArgumentList ]
	| PrimitiveType
	)
	[ Rank ]
.
/*B*/
BaseClause<Modifiers &mods> (. ID(L"BaseClause", STMT) .)
=
	(. if (scanner->Peek()->kind != _Unit) {
		IdentifierStatement();
		SyncNewline(s_name);
		return;
	} .)
	"Base" BaseUnitStatement<mods>
.
BaseUnitStatement<Modifiers &mods> (. ID(L"BaseUnitStatement", STMT) .)
=
	(.
	if (context.back() != _Program && context.back() != _Library) SemErr(L"BASE UNIT must be at module level (PROGRAM or LIBRARY)");

	mods.Let(s_Deprecated);
	mods.Check();
	.)
	"Unit" MandatoryIdent InUnitClause
	[
		"=" [OptionalNewline]
		Expression
	]
	SyncNewline<s_name>
.
BitShiftExpression (. ID(L"BitShift", EXPR) .)
=
	UnaryExpression { ( "SHL" | "SHR" ) UnaryExpression }
.
BlockBody<int kind, int line, int col, wchar_t *msg, bool nl>
=
	(. context.push_back(kind); .)
	{ Statement }
	(. context.pop_back(); .)
	(.
	if (la->kind != _End) {
		Err(line, col, msg);
	} else { // There is an END, but is it the correct one?
		int next = scanner->Peek()->kind;
		if ( next != _line_break && next != kind ) {
			Err(line, col, msg);
			Err(la->line, la->col, L"Incorrect END for this statement");

			// If this END agrees with an open block, let the next outer block have it.
			if (in_context(next)) return;

			// If no such block is open, discard the line.
			while (la->kind != _EOF && la->kind != _line_break) Get();
			if (nl) Newline();
			return;
		}
	} .)
	"End"
	(. Optional(kind); .)
	(. if (nl) Newline(); .)
.
BlockStatement<Modifiers &mods> (. ID(L"BlockStatement", STMT) .)
=
	( BaseClause<mods>
	| ClassStatement<mods>
	| ConstStatement<mods>
	| ConstructorStatement<mods>
	| DeclareStatement<mods>
	|
		(. mods.Check(); .) // No modifiers.
		DestructorStatement
	| DimStatement<mods>
	|
		(. mods.Check(); .) // No modifiers.
		DoStatement
	| EnumStatement<mods>
	|
		(. mods.Check(); .) // No modifiers.
		EventStatement
	|
		(. mods.Check(); .) // No modifiers.
		ForStatement
	| FunctionStatement<mods>
	|
		(. mods.Check(); .) // No modifiers.
		IfStatement
	| MethodStatement<mods>
	| NewStatement<&mods>
	| ObjectStatement<&mods>
	| PropertyStatement<mods>
	| SelectStatement<mods>
	| StructStatement<mods>
	| SubStatement<mods>
	| TraitStatement<mods>
	|
		(. mods.Check(); .) // No modifiers.
		TryStatement
	| UnitStatement<mods>
	|
		(. mods.Check(); .) // No modifiers.
		WhileStatement
	)
.
BracketedType (. ID(L"BracketedType", EXPR) .)
=
	"[" UserType "]"
	(. if (la->kind != _comma) Err(la->line, la->col, L"Bracketed type cannot be last argument"); .)
.
/*C*/
CallOrNew<int which, Modifiers *mods> (. ID(L"CallOrNew", STMT) .)
=
	(.
	bool bShared = mods ? mods->Let(s_Shared) : false;
	if (mods) mods->Check();
	.)

	(.
	if (0 == which) {
		if (bShared) {
			// Object declarations can have the modifier @SHARED. Calls cannot.
			which = _New;
		} else {
			// Heuristic to find if next token is a proc argument and not an object declaration:
			//	1. It is not an object name.
			//	2. It is a named argument.
			//	3. It is a name not followed by comma or newline.
			//	TODO: more?
			int next = 0; // Sentinal value.

			if (_hash == la->kind) next = scanner->Peek()->kind; // Move peek to after identifier.

			if ( (_identifier != la->kind && _hash != la->kind)
			|| _typed_identifier == la->kind // After this `la` is sure to be a name.
			|| _colon_equals == (next = scanner->Peek()->kind)
			|| (_comma != next && _line_break != next)
			) {
				which = _Call;
			}
			if (next) scanner->ResetPeek();
		}
	}

	if (_Call == which && option.args_enclosed) {
		Err(la->line, la->col, L"Argument list must be between parentheses ('(' ')') because of @OPTION");
	}
	.)

	UnenclosedArgumentList<&which> // Can contain `NewBeginStatement` after a comma+line_break.

	// TODO: Catch when the two styles of Begin are used together.

	[ IF (_line_break == la->kind && _Begin == scanner->Peek()->kind)
		SyncNewline<s_name>
		(.
		if (which != _Call) which = _New;
		else Err(la->line, la->col, L"Cannot use BEGIN in procedure call");
		.)
		NewBeginStatement
	]
.
CallStatement (. ID(L"CallStatement", STMT) .)
=
	"Call"
	( IF (la->kind == _Base && scanner->Peek()->kind != _dot)
		"Base"
		(.
		if (!in_context(_Constructor))
		    SemErr(L"CALL BASE is available only in a CONSTRUCTOR");
		.)
		OptionalArgList
	|
		"Constructor"
		(.
		if (!in_context(_Constructor))
		    SemErr(L"CALL CONSTRUCTOR is available only in a CONSTRUCTOR");
		.)
		OptionalArgList
	|
		SimpleExpression
		(.
		// If token is a name and there is more on the line, it is possibly a proc call with arguments.
		if (IsIdentifier(t->kind) && la->kind != _line_break)
			OptionalArgList();
		.)
	)
.
ClassStatement<Modifiers &mods> (. ID(L"ClassStatement", STMT) .)
=
	(.
	bool bAbstract = mods.Let(s_Abstract);
	mods.Let(s_Deprecated);
	bool bOpen     = mods.Let(s_Open);
	mods.Check();

	bool generic = false;
	.)
	"Class" (. int line = t->line, col = t->col; .)
	MandatoryIdent
	[ TypeParameterList<_Class> (. generic = true; .) ]
	[ IsOrExtendsOrInherits UserType ]
	[ DoesClause ]
	[ WhereClause<_Class, generic> ]
	SyncNewline<s_name>
	{ WhereClause<_Class, generic> SyncNewline<s_name> }
	BlockBody<_Class, line, col, L"CLASS without END">
.
ComparisonClause (. ID(L"ComparisonClause", STMT) .)
=
	(
		"Is" ComparisonOperator
		Expression
	|
		Expression
		[ "To" Expression ]
	)
.
ComparisonExpression (. ID(L"Comparison", EXPR) .)
=
	NullCoalescingExpression { ComparisonOperator NullCoalescingExpression }
.
ComparisonOperator (. ID(L"ComparisonOperator", STMT) .)
=
	[ "~" ]
	( "=" | "<>" | "<" | "<=" | ">" | ">=" )
.
ConcatenationExpression (. ID(L"Concatenation", EXPR) .)
=
	AdditiveExpression
	{
		concatenation AdditiveExpression
	}
.
///ConditionalComparison (. ID(ConditionalComparison) .)
///=
///	ComparisonOperator "Is" NullCoalescingExpression
///.
ConditionalExpression (. ID(L"Conditional", EXPR) .)
=
	"If" EnclosedExpression
	"Then" EnclosedExpression
	"Else" EnclosedExpression
.
ConstantValueError (. ID(L"ConstantValueError", STMT) .)
=
	(
		( char_literal | fixed_literal | integer_constant | integer_literal | null_literal
		| real_literal | string_constant | string_literal | time_literal | version_literal
		)
		(. SemErr(L"Cannot use a constant value here"); .)
	|
		malformed_char_literal
		(. SemErr(L"Bad escaped name or character literal - usually caused by missing backtick ('`')"); .)
	|
		( malformed_integer_literal | malformed_real_literal | malformed_string_literal )
		(. SemErr(L"Bad symbol"); .)
	)
.
ConstStatement<Modifiers &mods> (. ID(L"ConstStatement", STMT) .)
=
	(. int line = la->line, col = la->col; .)
	"Const"
	(
		(.
		mods.Let(s_Deprecated);
		if (mods.Let(s_Shared)) Warn(line, col, L"@SHARED has no effect on CONST");
		mods.Check();
		.)
		DeclaratorList
	|
		(. mods.Check(); .) // No modifiers.
		(. option_type nThen = WITHOUT_THEN; .)
		"If" TolExpression
		[ "Then" (. nThen = WITH_THEN; .) ]
		IfBlockStatement<false, line, col, nThen>
	)
	SyncNewline<s_name>
.
Constraint<int block> (. ID(L"Constraint", STMT) .)
=
	(
		(. int c = 0; .)

		identifier
		[ (. c++; .)
			( "<" | "<=" ) MandatoryIdent [ ( "<" | "<=" ) MandatoryIdent ]
		]
		[ (. c++; .)
			"Is" ( "Class" | "Struct" | "Unit" )
		]
		{ (. c++; .)
			"Does" UserType
		}
		[ (. c++; .)
			"Constructor" "(" ")"
		]
		(. if (c == 0) SemErr(L"invalid Constraint"); .)
	|
		"Self"
		(. if (block != _Class && block != _Trait) SemErr(L"SELF constraint only available in CLASS and TRAIT"); .)
		( "<" | "<=" | "Is" )
		UserType
	)
.
ConstructorStatement<Modifiers &mods> (. ID(L"ConstructorStatement", STMT) .)
=
	(.
	mods.Let(s_Deprecated);
	mods.Check();

	int line, col;
	bool var_construct = false;
	.)
	"Constructor" (. line = t->line; col = t->col; .)
	(. if (context.back() != _Class && context.back() != _Struct) SemErr(L"CONSTRUCTOR is available only in CLASS or STRUCT"); .)
	[
		DimOrVar
		(. var_construct = true; .)
	]
	(
		FormalParameterList<_Constructor>
	|
		(. if (var_construct) Err(L"CONSTRUCTOR DIM/VAR must have a parameter list"); .)
	)
	SyncNewline<s_name>
	(. if (var_construct) context.push_back(_Var); .)
	BlockBody<_Constructor, line, col, L"CONSTRUCTOR without END">
	(. if (var_construct) context.pop_back(); .)
.
/*D*/
DateTimeExpression (. ID(L"DateTime", EXPR) .)
=
	(
		integer_literal
		( "/" | "-" ) integer_literal
		( "/" | "-" ) integer_literal
		[ time_literal ]
	|
		time_literal
	)
.
Declarator (. ID(L"Declarator", STMT) .)
=
	Name
	[
		"("
		[
			// Eg 'Dim matrix(*2)'
			Rank                            
		|
			// Eg 'Dim matrix(3, 3)'
			EnclosedExpression
			{ WEAK comma
				EnclosedExpression
			} 
		]
		")"
	]
	[ TypeClause ]
	[
		"=" [OptionalNewline]
		InitializationExpression
	]
.
DeclaratorList (. ID(L"DeclaratorList", STMT) .)
=
	Declarator
	{
		WEAK comma [OptionalNewline]
		Declarator
	}
.
DeclareParameter<bool &isOptional> (. ID(L"DeclareParameter", STMT) .)
=
	[ "Optional" (. isOptional = true; .) ]
	integer_literal
	[
		"=" [OptionalNewline]
		EnclosedExpression
	]
.
DeclareSignature<bool isAlias> (. ID(L"DeclareSignature", STMT) .)
=
	( "Function" | "Sub" )
	Name
	[
		"Is"
		(. std::wstring qn; .)
		(
			string_literal (. qn += t->val; .)
		|
			QualifiedName<qn, 0>
		)
	]
	[
		(. bool isOptional; .)
		( IF (IsDeclareParameterList())
			"(" [OptionalNewline]
			[
				DeclareParameter<isOptional>
				{ WEAK comma [OptionalNewline]
					DeclareParameter<isOptional>
				}
			]
			")"
		|
			EnclosedParameterList<_Declare>
			[ TypeClause ]
		)
	]
.
DeclareStatement<Modifiers &mods> (. ID(L"DeclareStatement", STMT) .)
=
	(.
	mods.Let(s_Deprecated);
	mods.Let(s_Platform);
	mods.Check();

	int line, col;
	bool bAnsi = false, bCdecl = false, bUtf16 = false;
	.)
	(. bool isAlias = true; .)
	"Declare" (. line = t->line; col = t->col; .)
	[
		(
			string_literal
		|
			identifier
			(. SemErr(L"external library must be a string constant"); .)
		)
		{
			[ comma ]
			MandatoryIdent
			(.
			if (Matches(L"ANSI")) {
				if (bUtf16) SemErr(L"Cannot use ANSI with UTF16");
				if (!bAnsi) bAnsi = true;
				else Warn(t->line, t->col, L"ANSI given more than one time");
			} else if (Matches(L"CDECL")) {
				if (!bCdecl) bCdecl = true;
				else Warn(t->line, t->col, L"CDECL given more than one time");
			} else if (Matches(L"UTF16")) {
				if (bAnsi) SemErr(L"Cannot use UTF16 with ANSI");
				if (!bUtf16) bUtf16 = true;
				else Warn(t->line, t->col, L"UTF16 given more than one time");
			} else SemErr(L"Unknown identifier. After DECLARE only ANSI, CDECL, and UTF16 are available.");
			.)
		}
		(. isAlias = false; .)
	]
	(
		DeclareSignature<isAlias>
	|
		SyncNewline<s_name>
		(. context.push_back(_Declare); .)
		{ DeclareSignature<isAlias> Newline }
		(. context.pop_back(); .)
		(. if (la->kind != _End) Err(line, col, L"DECLARE without END"); .)
		"End"
		(. Optional(_Declare); .)
	)
	SyncNewline<s_name>
.
Deprecated (. ID(L"Deprecated", STMT) .)
=
	(. Modifiers mods(this); .)
	ModifiersClause<mods>
	(.
	mods.Let(s_Deprecated);
	mods.Check();
	.)
.
DestructorStatement (. ID(L"DestructorStatement", STMT) .)
=
	(.
	int line, col;
	.)
	"Destructor" (. line = t->line; col = t->col; .)
	(. if (context.back() != _Class) SemErr(L"DESTRUCTOR is available only in CLASS"); .)
	Newline
	BlockBody<_Destructor, line, col, L"DESTRUCTOR without END">
.
DimOrVar (. ID(L"DimOrVar", STMT) .)
=
	( "Dim"  (. if (option.Dim_or_Var == TERNARY2) SemErr(L"Must use VAR because of @OPTION"); .)
	| "Var"  (. if (option.Dim_or_Var == TERNARY1) SemErr(L"Must use DIM because of @OPTION"); .)
	)
.
DimStatement<Modifiers &mods> (. ID(L"DimStatement", STMT) .)
=
	(.
	bool bShared = mods.Let(s_Shared);
	mods.Check();
	.)
	DimOrVar
	DeclaratorList
	SyncNewline<s_name>
.
DivisionFunction (. ID(L"Division", EXPR) .)
=
	(. bool two_args = false; .)
	(
		"Div"
	|
		"Mod"
		(. two_args = true; .)
		(. Count_MOD(); .)
	|
		"Rem"
		(. two_args = true; .)
		(. Count_REM(); .)
	)
	"(" EnclosedExpression
	comma EnclosedExpression
	[
		comma
		(. if (two_args) SemErr(L"Too many arguments for MOD or REM"); .)
		EnclosedExpression
	]
	")"
.
DoesClause (. ID(L"DoesClause", STMT) .)
=
	"Does" UserType
	{ WEAK comma [OptionalNewline]
		UserType
	}
.
DoStatement (. ID(L"DoStatement", STMT) .)
=
	"Do" (. int line = t->line, col = t->col; .)
	(	// `Do...Loop While/Until`.
		( Newline
		| (. if (false) .) "Exit" // KLUDGE: Permit `Do Exit When`.
		)
		(. context.push_back(_Do); .)
		[ LoopBody<POSTCONDITIONAL> ]
		(. context.pop_back(); .)
		(. if (la->kind != _Loop) Err(line, col, L"DO without LOOP"); .)
		"Loop" WhileOrUntil TolExpression
		SyncNewline<s_name>
	|	// `Do While/Until...Loop`.
		WhileOrUntil TolExpression
		SyncNewline<s_name>
		(. context.push_back(_Do); .)
		[ LoopBody<PRECONDITIONAL> ]
		(. context.pop_back(); .)
		"Loop"
		[ WhileOrUntil (. SemErr(L"DO WHILE/UNTIL cannot have LOOP WHILE/UNTIL"); .) ]
		SyncNewline<s_name>
	)
.
/*E*/
EnclosedArgumentList (. ID(L"EnclosedArgumentList", STMT) .)
=
	"(" [OptionalNewline]
	[
		Argument
	|
		BracketedType
	]
	{
		WEAK comma
		[
			[OptionalNewline]
			(
				Argument
			|
				BracketedType
			)
		]
	}
	")"
.
EnclosedExpression (. ID(L"Enclosed", EXPR) .)
=
	( IF (_If == la->kind)
		(. if (t->kind != _left_paren) Err(la->line, la->col, L"IF-THEN-ELSE must be between parentheses"); .)
		ConditionalExpression
	|
		LogicalExpression
	)
.
EnclosedParameterList<int parent> (. ID(L"EnclosedParameterList", STMT) .)
=
	(. param_validator param(this, parent); .)
	"(" [OptionalNewline]
	(
		FormalParameter<param>
		{
			WEAK comma [OptionalNewline]
			FormalParameter<param>
		}
	|
		(. param.None(); .)
	)
	")"
.
EnumStatement<Modifiers &mods> (. ID(L"EnumStatement", STMT) .)
=
	(.
	#define FLAGS X(Closed); X(Flags); X(MustUse);
	#define X _MODS_DECL_FLAGS
	FLAGS
	#undef X
	#define X _MODS_INIT_FLAGS
	if (mods.Count()) {
		mods.Let(s_Deprecated);
		FLAGS
		mods.Check();
	}
	#undef X
	#undef FLAGS
	.)
	"Enum" (. int line = t->line, col = t->col; .)
	MandatoryIdent
	[
		IsOrExtendsOrInherits
		( PrimitiveType | UserType )
		(. if (!IsEnumBaseType(t->kind)) Err(L"Base type must be an integer type or enumeration type"); .)
	] (. else if (bFlags) {
		Err(L"Enumeration must have a base type because of @FLAGS");
	} .)
	SyncNewline<s_name>
	(. context.push_back(_Enum); .)
		(. bool deprecated_const = false; .)
	{
		[ Deprecated (. deprecated_const = true; .) ]
		MandatoryIdent
		[
			"=" [OptionalNewline]
			Expression
		] (. else if (option.Enum_equals) SemErr(L"Enumeration constant must have an initializer because of @OPTION"); .)
		(.
		if (_comma == la->kind) {
			Get();
			// This error can be very frequent for a person that knows many other programming languages.
			if (errors->count < 3) Err(L"Separator must be a semicolon (;)");
			continue;
		} .)
		SyncSeparator<s_name>
		(.
		if (deprecated_const && t->kind == _semicolon && la->kind != _at_sign) {
			Warn(la->line, la->col, L"@DEPRECATED has no effect on this constant. We recommend a line-break here.");
			deprecated_const = false; // Stop the warnings.
		} .)
	}
	(. context.pop_back(); .)
	// Make sure last EnumMember ends with EOL.
	(. if (t->kind != _line_break) SynErr(_line_break); .)
	(. if (la->kind != _End) Err(line, col, L"ENUM without END"); .)
	"End"
	(. Optional(_Enum); .)
	Newline
.
EventSpecifier (. ID(L"EventSpecifier", STMT) .)
=
	[ ObjectName ]
	(. else .) // KLUDGE: Prevent a small token set.
	[ "Base" | "Self" ]
	(. else Err(L"Event specifier must start with an object, BASE, or SELF"); .)
	dot MandatoryIdent
.
EventStatement (. ID(L"EventStatement", STMT) .)
=
	(. bool generic = false; .)
	"Event" MandatoryIdent
	[ TypeParameterList<_Event> (. generic = true; .) ]
	[ FormalParameterList<_Event> ]
	[ WhereClause<_Event, generic> ]
	SyncNewline<s_name>
.
ExitBlock<int &kind, wchar_t *&msg> (. ID(L"ExitBlock", STMT) .)
=
	// Returns kind of block, possible error msg.
	(. kind = la->kind; .)
	(
		"Constructor"
		(. msg = L"EXIT CONSTRUCTOR without CONSTRUCTOR"; .)
	|
		"Do"
		(. msg = L"EXIT DO without DO"; .)
	|
		"For"
		(. msg = L"EXIT FOR without FOR"; .)
	|
		"Function"
		(. msg = L"EXIT FUNCTION without FUNCTION"; .)
	|
		"Method"
		(. msg = L"EXIT METHOD without METHOD"; .)
	|
		"Property"
		(. msg = L"EXIT PROPERTY without PROPERTY"; .)
	|
		"Sub"
		(. msg = L"EXIT SUB without SUB"; .)
	|
		"While"
		(. msg = L"EXIT WHILE without WHILE"; .)
	)
	(.
	if (la->kind == _comma && kind != _Do && kind != _For && kind != _While)
		SemErr(L"EXIT list can use only DO or FOR or WHILE");
	.)
.
ExitStatement (. ID(L"ExitStatement", STMT) .)
=
	"Exit"
	(.
	if (in_context(_Finally))
	    SemErr(L"Cannot use EXIT in FINALLY");
	.)
	(
		identifier
		(.
		if (!in_context(_When))
		    SemErr(L"EXIT label without EXIT WHEN");
		.)
	|
		(. int kind = 0; wchar_t *msg = nullptr; .)
		ExitBlock<kind, msg>
		(.
		auto it = std::find(context.rbegin(), context.rend(), kind);
		if (it == context.rend()) SemErr(msg);
		.)
		{
			WEAK comma
			ExitBlock<kind, msg>
			(.
			it = std::find(++it, context.rend(), kind);
			if (it == context.rend()) SemErr(msg);
			.)
		}
	|
		"Program"
		(.
		if (context[0] != _Program)
		    SemErr(L"Cannot use EXIT PROGRAM in LIBRARY");
		.)
		[ EnclosedExpression ]
	)
.
Expression (. ID(L"Expression", EXPR) .)
=
	(
		EnclosedExpression
	|
		LambdaExpression
	)
	(.
	if (_right_paren == la->kind) {
		Get();
		SemErr(L"More right parentheses than left");
	}

	switch (la->kind) {
	case _colon_equals: case _comma: case _line_break: case _right_brace: case _semicolon: case _Else: case _Step: case _Then: case _To: case _Tol:
		// For all tokens that can follow an expression.
		// Do nothing.
		break;
	default:
		if (_typed_identifier == t->kind || _at_sign == t->kind) {
			// For those that think type characters are operators.
			Err(la->line, la->col, L"Possibly missing operator after type character");
		} else {
			Err(la->line, la->col, L"Possibly missing operator");
		}
	} .)
.
/*F*/
FormalParameter<param_validator &param> (. ID(L"FormalParameter", STMT) .)
=
	[
		"ByRef"     (. param.Add(_ByRef); .)
	|
		"Optional"  (. param.Add(_Optional); .)
	] (. else param.Add(); .)
	Name
	[ "(" [ Rank ] ")" ]
	[ TypeClause ]
	(
		"=" [OptionalNewline]
		EnclosedExpression
	|
		(. if (param.Optional() && option.Optional_equals) SemErr(L"Optional parameter must have initializer because of @OPTION"); .)
	)
.
FormalParameterList<int parent> (. ID(L"FormalParameterList", STMT) .)
=
	( EnclosedParameterList<parent> | UnenclosedParameterList<parent> )
.
ForStatement (. ID(L"ForStatement", STMT) .)
=
	(. int line, col; .)
	"For" (. line = t->line; col = t->col; .)
	(
		"Each" LoopControlVariable
		"In" InitializationExpression
	|
		LoopControlVariable
		[
			"In"
			(. Err(L"Error with two possible causes: "
				L"(1) FOR EACH is missing EACH. "
				L"(2) Data type of FOR variable must be an integer."
			); .)
		]
		"=" Expression
		"To" Expression
		[ "Step" Expression ]
	)
	SyncNewline<s_name>
	(. context.push_back(_For); .)
	[ LoopBody<PRECONDITIONAL> ]
	(. context.pop_back(); .)
	(.
	if (la->kind != _End) {
		Err(line, col, L"FOR without END");
	} else { // There is an END, but is it the correct one?
		int next = scanner->Peek()->kind;
		if ( next != _line_break && next != _For ) {
			Err(line, col, L"FOR without END");
			Err(la->line, la->col, L"Incorrect END for this statement");

			// If this END agrees with an open block, let the next outer block have it.
			if (in_context(next)) return;

			// If no such block is open, discard the line.
			while (la->kind != _EOF && la->kind != _line_break) Get();
			Newline();
			return;
		}
	} .)
	"End"
	(. Optional(_For); .)
	Newline
.
FunctionSignature<Modifiers &mods, int &line, int &col, bool &bodied, bool &generic> (. ID(L"FunctionSignature", STMT) .)
=
	"Function" (. line = t->line; col = t->col; .)
	Name
	(. bool typed_name = (t->kind == _typed_identifier); .)
	(
		[ TypeParameterList<_Function> (. generic = true; .) ]
		[ EnclosedParameterList<_Function> ]
		( ReturnTypeClause
		| (. if (!typed_name) SemErr(L"FUNCTION must have a return type"); .)
		)
		[ WhereClause<_Function, generic> ]
	|
		"Does" MandatoryIdent dot Name
		(. bodied = false; .)
	)
	SyncNewline<s_name>
.
FunctionStatement<Modifiers &mods> (. ID(L"FunctionStatement", STMT) .)
=
	(.
	mods.Let(s_Deprecated);
	bool bIterator = mods.Let(s_Iterator);
	bool bShared   = mods.Let(s_Shared);
	mods.Check();

	int line, col;
	bool bodied = true;
	bool generic = false;
	.)
	FunctionSignature<mods, line, col, bodied, generic>
	[ IF (bodied)
		{ WhereClause<_Function, generic> SyncNewline<s_name> }
		(. if (bIterator) context.push_back(_Yield); .)
		BlockBody<_Function, line, col, L"FUNCTION without END">
		(. if (bIterator) context.pop_back(); .)
	]
.
/*G*/
GotoStatement (. ID(L"GotoStatement", STMT) .)
=
	"Goto"
	(.
	if (!in_context(_Select))
	    SemErr(L"GOTO CASE without SELECT");

	if (in_context(_Finally))
	    SemErr(L"Cannot use GOTO CASE in FINALLY");
	.)
	"Case" ( "Else" | TolExpression )
.
/*H*/
/*I*/
IdentifierStatement (. ID(L"IdentifierStatement", STMT) .)
=
	// Related: SimpleExpression
	(.
	if (_Base == la->kind) { // KLUDGE: Called from `BaseClause`.
		Get();
		// TODO: Test for base class.
	} else .)
	(
		Name
		[ TypeArgumentList ]
	|
		"Self"
	)
	{
		[ // Null-conditional operators.
			"?"
			(. if ( HasWhitespace(1) || (_dot != la->kind && _left_paren != la->kind && _exclamation != la->kind) ) {
				Err(L"Bad operator");
			} .)
		]
		( // Member access (eg `obj . member` or `#obj ?. member`).
			"." Name [ TypeArgumentList ]
		| // Argument list or array subscript (`proc ( args )` or `obj ( indexes )` or `#obj ?( indexes )`).
			EnclosedArgumentList
			// FIXME: `EnclosedArgumentList` + `CallOrNew` causes "LL1 warning in IdentifierStatement: left_paren is start & successor of deletable structure".

		| // Error.
			(. int line = (_question == t->kind) ? t->line : la->line; .)
			(. int col = (_question == t->kind) ? t->col : la->col; .)
			"!" (. Err(line, col, L"Cannot use dictionary-access operator ('!' or '?!') here"); .)
			Name
		)
	}
	[ IF (IsAssignmentOp())
		AssignmentStatement
	|
		// Variable declaration (`foo AS type` or `bar IN unit`).
		TypeClause
		[
			"=" [OptionalNewline]
			InitializationExpression
		]
	|
		(. // Check for typo.
		if ( _identifier == t->kind && Matches(L"ForEach") ) Warn(t->line, t->col, L"Possibly you want FOR EACH?");
		.)
		CallOrNew<0, nullptr>
	]
.
IfBlockStatement<bool bBlock, int line, int col, option_type nThen> (. ID(L"IfBlockStatement", STMT) .)
=
	(. bool bElseSeen = false; .)
	(. Optional(_Then, nThen); .)
	SyncNewline<s_name>
	(. if (bBlock) context.push_back(_If); .)
	{ Statement }
	{
		"Else"
		(. if (bElseSeen) SemErr(L"ELSE or ELSE IF cannot follow ELSE"); .)
		[
			"If" TolExpression (. Optional(_Then); .)
		] (. else bElseSeen = true; .)
		SyncNewline<s_name>
		{ Statement }
	}
	(. if (bBlock) context.pop_back(); .)
	(.
	if (la->kind != _End) {
		Err(line, col, L"IF without END");
	} else { // There is an END, but is it the correct one?
		int next = scanner->Peek()->kind;
		if ( next != _line_break && next != _If ) {
			Err(line, col, L"IF without END");
			Err(la->line, la->col, L"Incorrect END for this statement");

			// If this END agrees with an open block, let the next outer block have it.
			if (in_context(next)) return;

			// If no such block is open, discard the line.
			while (la->kind != _EOF && la->kind != _line_break) Get();
			Newline();
			return;
		}
	} .)
	"End"
	(. Optional(_If); .)
.
IfStatement (. ID(L"IfStatement", STMT) .)
=
	(. int line = la->line, col = la->col; .)
	"If"
	TolExpression
	(
		"Then"
		(
			IfBlockStatement<true, line, col, WITH_THEN>
		|
			(. if (option.If_End) SemErr(L"IF must use block construct because of @OPTION"); .)
			( SimpleStatement | SimpleStatementError )
			[ "Else" ( SimpleStatement | SimpleStatementError ) ]
			(. if (_semicolon == la->kind) Err(la->line, la->col, L"Cannot have more than one statement after THEN or ELSE"); .)
		)
	|
		IfBlockStatement<true, line, col, WITHOUT_THEN>
	)
	Newline
.
InitializationElement (. ID(L"InitializationElement", STMT) .)
=
	[ IF (IsUnorderedInit())
		[ char_literal | integer_constant | integer_literal ] // Use [...] because no error msg is necessary.
		":="
	]
	InitializationExpression
.
InitializationExpression (. ID(L"InitializationExpression", STMT) .)
=
	(
		Expression
	|
		"{" [OptionalNewline]
		InitializationElement
		{ WEAK comma [OptionalNewline]
			InitializationElement
		}
		"}"
		// Permit isolated right brace.
		[ IF (la->kind == _line_break && scanner->Peek()->kind == _right_brace)
			line_break
		]
	)
.
InUnitClause (. ID(L"InUnitClause", STMT) .)
=
	"In" UnitOrSuffix<_Unit>
.
IsOrExtendsOrInherits
=
	(. bool unwanted = false; .)
	(
		"Is"
		(. if (option.type_is != Option::EII::DEFAULT && option.type_is != Option::EII::Is) unwanted = true; .)
	|
		( identifier | "As" ) // "As" is not the same as "Is". This makes a better error message.
		(.
		if (Matches(L"EXTENDS")) {
			if ( option.type_is != Option::EII::DEFAULT && option.type_is != Option::EII::Extends ) unwanted = true;
		} else if (Matches(L"INHERITS")) {
			if ( option.type_is != Option::EII::DEFAULT && option.type_is != Option::EII::Inherits ) unwanted = true;
		} else {
			Err(L"Must be one of these: IS, EXTENDS, or INHERITS");
		}
		.)
	)
	(.
	if (unwanted) {
		std::wstring msg(L"Must use ");
		switch (option.type_is) {
			case Option::EII::Extends:  msg += L"EXTENDS"; break;
			case Option::EII::Inherits: msg += L"INHERITS"; break;
			case Option::EII::Is:       msg += L"IS"; break;
			default: errors->Exception(L"Unhandled case for `option.type_is`");
		}
		msg += L" because of @OPTION";
		Err(msg.c_str());
	} .)
.
/*J*/
/*K*/
/*L*/
LambdaExpression (. ID(L"Lambda", EXPR) .)
=
	(. int line, col; .)
	(
		"Function" (. line = t->line; col = t->col; .)
		(
			Name // Operator to get address.
		|
			EnclosedParameterList<_Event>
			(
				EnclosedExpression
			|
				LambdaFunction<line, col>
			)
		|
			LambdaFunction<line, col>
		)
	|
		"Sub" (. line = t->line; col = t->col; .)
		(
			Name // Operator to get address.
		|
			EnclosedParameterList<_Event>
			(
				EnclosedExpression
			|
				LambdaSub<line, col>
			)
		|
			LambdaSub<line, col>
		)
	)
.
LambdaFunction<int line, int col> (. ID(L"LambdaFunction", STMT) .)
=
	SyncNewline<s_name>
	BlockBody<_Function, line, col, L"FUNCTION lambda without END", false>
.
LambdaSub<int line, int col> (. ID(L"LambdaSub", STMT) .)
=
	SyncNewline<s_name>
	BlockBody<_Sub, line, col, L"SUB lambda without END", false>
.
LogicalExpression (. ID(L"Logical", EXPR) .)
=
	ComparisonExpression
	{
		LogicalOperator
		ComparisonExpression
	}
	(.
	// If incorrectly typed logical operator.
	// Eg: If x AndThen ...
	// Related code in `UnitOrSuffix`.
	if (_identifier == la->kind && (Match(L"AndThen") || Match(L"OrElse"))) {
		Err(L"Operators AND THEN and OR ELSE must be two words");
		ComparisonExpression();
	}
	.)
.
LogicalOperator (. ID(L"LogicalOperator", STMT) .)
=
	( "And" [ "Then" ]
	| "Or" [ "Else" ]
	| "Xor"
	)
.
LoopControlVariable (. ID(L"LoopControlVariable", STMT) .)
=
	( ObjectName [ AsTypeClause ]
	| typed_identifier
	)
.
LoopBody<bool isPreconditional> (. ID(L"LoopBody", STMT) .)
=
	( IF (la->kind == _Exit && scanner->Peek()->kind == _When)
		(. when_map whens; .)
		"Exit" (. int line = t->line, col = t->col; .)
		"When"
		[
			identifier
			(.
			std::wstring id(t->val);
			std::transform(id.begin(), id.end(), id.begin(), std::towupper);
			whens[id]++;
			.)
			{ WEAK comma
				MandatoryIdent
				(.
				std::wstring id(t->val);
				std::transform(id.begin(), id.end(), id.begin(), std::towupper);
				if (++whens[id] == 2) {
					SemErr(L"EXIT WHEN cannot have two of the same label");
					whens[id] = 1;
				}
				.)
			}
		]
		SyncNewline<s_name>
		(. context.push_back(_When); .)
		{ Statement }
		(. context.pop_back(); .)
		WhenStatement<isPreconditional, whens>
		{ WhenStatement<isPreconditional, whens> }
		// TODO: if @Option When ID, make sure labels agree with When's.
	|
		[ IF (la->kind == _Exit)
			(. Err(la->line, la->col, L"EXIT cannot be first statement in loop. Possibly you want EXIT WHEN."); .)
			ExitStatement
			SyncNewline<s_name>
			// Return if EXIT was the only statement.
			(. if (la->kind == _End || la->kind == _Loop) return; .)
		]
		Statement { Statement }
	)
.
/*M*/
MandatoryIdent
=
	// Related: `Name`.
	(. // Make sure it is not a keyword.
	if (scanner->IsKeyword(la->kind)) {
		Get();
		SemErr(L"Keyword cannot be used as an identifier here");
		return;
	} .)
	identifier
.
MethodStatement<Modifiers &mods> (. ID(L"MethodStatement", STMT) .)
=
	(.
	#define FLAGS X(Abstract); X(Const); X(Iterator); X(MustUse); X(Open); X(Override); X(Shared);
	#define X _MODS_DECL_FLAGS
	FLAGS
	#undef X
	#define X _MODS_INIT_FLAGS
	if (mods.Count()) {
		mods.Let(s_Deprecated);
		FLAGS
		mods.Check();
	}
	#undef X
	#undef FLAGS

	int line, col;
	.)
	MethodSignature<mods, line, col>
	(. if (bIterator) context.push_back(_Yield); .)
	BlockBody<_Method, line, col, L"METHOD without END">
	(. if (bIterator) context.pop_back(); .)
.
MethodSignature<Modifiers &mods, int &line, int &col> (. ID(L"MethodSignature", STMT) .)
=
	"Method"
	(.
	line = t->line; col = t->col;
	// If in a program module
	if (context.back() == _Program)
	    SemErr(L"Cannot use METHOD in PROGRAM module");
	.)
	Name
	(. bool bReturns = (t->kind == _typed_identifier); .)
	[
		EnclosedParameterList<_Method>
		[
			ReturnTypeClause
			(. bReturns = true; .)
		]
	|
		UnenclosedParameterList<_Method>
	|
		ReturnTypeClause
		(. bReturns = true; .)
	]
	(.
	if (!bReturns && mods.Has(s_Const) || mods.Has(s_MustUse))
		SemErr(L"Method must have return type because of modifier(s)");
	.)
	SyncNewline<s_name>
.
Modifier<struct Modif *&pMod> (. ID(L"Modifier", STMT) .)
=
	(.
	pMod = nullptr; // Sentinel.
	.)
	"@" (. int line = t->line, col = t->col; .)
	(. if (HasWhitespace(1)) Err(L"Bad modifier"); .)
	(
		// @Const
		(.
		if (_If == scanner->Peek()->kind) return; // "@CONST IF" is an alternative to "CONST IF".
		.)
		"Const" (. pMod = new ConstModif(line, col); .)
	|
		identifier
		(.
		switch (coco_string_length(t->val)) {
		case 2:
			if (Matches(L"SI")) {
				SIModif::SIArg arg = SIModif::SIArg::_NA;
				if (_identifier == la->kind) {
					Get();
					if (Matches(L"BINARY")) arg = SIModif::SIArg::BINARY; else
					if (Matches(L"LARGE")) arg = SIModif::SIArg::LARGE; else
					if (Matches(L"SMALL")) arg = SIModif::SIArg::SMALL;
					else Err(L"Unknown identifier after @SI. Only BINARY, LARGE, and SMALL are available.");
				}
				pMod = new SIModif(line, col, arg);
			}
			break;
		case 4:
			if (Matches(L"Open")) pMod = new OpenModif(line, col); else
			if (Matches(L"Test")) {
				TestModif::TestArg arg = TestModif::TestArg::_NA;
				if (_identifier == la->kind) {
					Get();
					if (Matches(L"IGNORE")) arg = TestModif::TestArg::IGNORED;
					else Err(t->line, t->col, L"Unknown identifier. After @TEST, only IGNORE is available.");
				}
				pMod = new TestModif(line, col, arg);
			}
			break;
		case 5:
			if (Matches(L"Flags")) pMod = new FlagsModif(line, col);
			break;
		case 6:
			if (Matches(L"Backed")) pMod = new BackedModif(line, col); else
			if (Matches(L"Closed")) pMod = new ClosedModif(line, col); else
			if (Matches(L"Shared")) pMod = new SharedModif(line, col); else
			if (Matches(L"Strict")) pMod = new StrictModif(line, col);
			break;
		case 7:
			if (Matches(L"MustUse")) pMod = new MustUseModif(line, col);
			break;
		case 8:
			if (Matches(L"Abstract")) pMod = new AbstractModif(line, col); else
			if (Matches(L"Iterator")) pMod = new IteratorModif(line, col); else
			if (Matches(L"Override")) pMod = new OverrideModif(line, col); else
			if (Matches(L"Platform")) {
				if (_identifier == la->kind) {
					Get();
					std::wstring needle{L'|'};
					wchar_t * pName = coco_string_create_lower(t->val);
					needle += pName;
					needle += L'|';
					if (wcsstr(L"|win32|windows|", needle.c_str())) {
						pMod = new PlatformModif(line, col); // TODO: Pass identifier as argument.
					} else Err(L"Unknown identifier after @PLATFORM.");
					delete pName;
				} else Err(la->line, la->col, L"Missing mandatory identifier after @PLATFORM");
			} else
			if (Matches(L"ReadOnly")) pMod = new ReadOnlyModif(line, col);
			break;
		case 9:
			if (Matches(L"WriteOnly")) pMod = new WriteOnlyModif(line, col);
			break;
		case 10:
			if (Matches(L"Deprecated")) {
				wchar_t *pVal = nullptr;
				if (_string_literal == la->kind) {
					Get(); pVal = t->val;
				} 
				pMod = new DeprecatedModif(line, col, pVal);
			}
			break;
		}
		if (nullptr == pMod) SemErr(L"Invalid directive or modifier");
		.)
	)
	[ OptionalNewline ]
.
ModifiersClause<Modifiers &mods> (. ID(L"ModifiersClause", STMT) .)
=
	(. struct Modif *pMod; .)
	Modifier<pMod>
	(. mods.Add(pMod); .)
	{
		Modifier<pMod>
		(. mods.Add(pMod); .)
	}
.
Module (. ID(L"Module", STMT) .)
=
	(. int module_type = _Program; .)
	[ Newline ]
	[
		"Library"
		(.
		module_type = _Library;
		module = new AST::Module(AST::Module::Library, t->line, t->col);
		context.push_back(_Library);

		std::wstring qn;
		.)
		QualifiedName<qn, _identifier>
		SyncNewline<s_name>
	|
		"Program"
		(.
		module = new AST::Module(AST::Module::Program, t->line, t->col);
		context.push_back(_Program);
		.)
		[ "=" (. module_type = _Sub; module->procStart = true; .) ]
		MandatoryIdent (. module->Name(t->val); .)
		SyncNewline<s_name>
	]
	(.
	if (module == nullptr) { // Default is program module.
		module = new AST::Module(AST::Module::Program, la->line, la->col); // Use 'la' because 't' can be the dummy token.
		context.push_back(_Program);
	}
	.)
	{ IF (_Where == la->kind)
		"Where" (. int line = t->line, col = t->col; .)
		MandatoryIdent  (. wchar_t *id = coco_string_create(t->val); .)
		"="
		[
			DateTimeExpression
		|
			(. std::wstring s; .)
			StringExpression<s>
			(. module->Add(new AST::ModuleWhere(id, _wcsdup(s.c_str()), AST::STRING, line, col)); .)
		|
			version_literal 
			(. module->Add(new AST::ModuleWhere(id, coco_string_create(t->val), AST::VERSION, line, col)); .)
		] (. else Err(L"In WHERE, value must be a literal of date/time, string, or version number"); .)
		(. if (la->kind != _line_break) Err(L"WHERE cannot be a list or expression"); .)
		SyncNewline<s_name>
	}

	{ IF (_Require == la->kind)
		(. std::wstring qn; .)
		"Require"
		QualifiedName<qn, _identifier> [ "As" MandatoryIdent ]
		(
			{ WEAK comma
			(. qn.clear(); .)
				QualifiedName<qn, _identifier>
				[ "As" MandatoryIdent ]
			}
			(. if (_Where == la->kind) Err(la->line, la->col, L"Cannot use WHERE after a list"); .)
		|
			"Where" RequireLogic
		)
		SyncNewline<s_name>
		(. if (_Where == la->kind) Err(la->line, la->col, L"WHERE must be on the same logical line as REQUIRE"); .)
	}
	{ ModuleStatement<(module_type == _Sub)> }
.
ModuleStatement<bool bProcEntry> (. ID(L"ModuleStatement", STMT) .)
=
	///(. if (bProcEntry) Warn(L"Executable statements at module level ignored when entry point is a procedure"); .)
	(. Modifiers mods(this); .)
	(. m_start_col = la->col; .)
	[ ModifiersClause<mods> ]
	(
		BlockStatement<mods>
	|
		(. mods.Check(); .) // No modifiers.
		SimpleStatement
		{ ";" SimpleStatement }
		SyncNewline<s_name>
	)
.
MultiplicativeExpression (. ID(L"Multiplicative", EXPR) .)
=
	PowerExpression
	{
		(
			"*"
		|
			"/"
		|
			"\\"
		|
			"Div"
		|
			"Mod"
			(. Count_MOD(); .)
		|
			"Rem"
			(. Count_REM(); .)
		)
		PowerExpression
	}
.
/*N*/
Name (. ID(L"Name", STMT) .)
=
	// Related: `MandatoryIdent`.
	[ "#" ]
	(.
	if (scanner->IsKeyword(la->kind)) {
		Get();
		SemErr(L"Keyword cannot be used as an identifier here");
		return;
	} .)
	(
		identifier
	|
		typed_identifier
	)
.
///NamespaceStatement<Modif &mods> (. ID(L"NamespaceStatement", STMT) .)
///=
///	(.
///	mods.allow(Modif::Deprecated);
///	mods.validate();
///	.)
///	"Namespace" QualifiedName<_identifier> SyncNewline<s_name>
///	{ ModuleMember }
///	"End"
///	(. Optional(_Namespace); .)
///	Newline
///.
NewBeginStatement (. ID(L"NewBeginStatement", STMT) .)
=
	(.
	int line, col;
	int limit = 0;
	wchar_t *type_name = nullptr; // TODO: make this a parameter
	.)
	"Begin" (. line = t->line; col = t->col; .)
	[
		"Call"
		(. limit = _Call; .)
		[
			SimpleNonCallExpression // Default is "Add".
		]
	|
		UserType
	]
	SyncNewline<s_name>
	(. context.push_back(_New); .)
	{
		( IF (_left_paren == la->kind)
			EnclosedArgumentList
		|
			[ BracketedType comma ]
			UnenclosedArgumentList<nullptr>
		)
		SyncSeparator<s_name>
	}
	(. context.pop_back(); .)
	(. if (t->kind != _line_break) SynErr(_line_break); .)
	(. if (la->kind != _End) Err(line, col, L"NEW...BEGIN without END"); .)
	"End"
	(
		"New"
		(. if (option.End_block == NO) SemErr(L"END cannot have  block type because of @OPTION"); .)
	|
		identifier
		(. if (option.End_block == NO) SemErr(L"END cannot have  type name because of @OPTION"); .)
		(. if (!type_name || !Matches(type_name)) SemErr(L"END type name must be the same as NEW type name"); .)
	|
		(. if (option.End_block == YES) SemErr(L"END must have block type because of @OPTION"); .)
	)
	(. coco_string_delete(type_name); .)
.
NewStatement<Modifiers *mods> (. ID(L"NewStatement", STMT) .)
=
	"New" UserType CallOrNew<_New, mods>
	SyncNewline<s_name>
.
Newline (. ID(L"Newline", STMT) .)
=
	line_break { line_break }
.
NullCoalescingExpression (. ID(L"NullCoalescing", EXPR) .)
=
	TypeExpression [ "??" NullCoalescingExpression ]
.
NumericExpression<bool bMixedUnit> (. ID(L"Numeric", EXPR) .)
=
	(.
	static const wchar_t *s_msg = L"Bad fixed constant";
	bool bFixed = false;
	int line = la->line, col = la->col;
	.)
	[
		( "@" | fixed_literal )
		(.
		bFixed = true;
		if (HasWhitespace()) Err(line, col, s_msg);
		.)
	]
	( IF (IsDateTime())
		DateTimeExpression
	|
		integer_literal
	|
		real_literal
		(. if ( (bFixed || _at_sign == la->kind) && L'!' == t->val[coco_string_length(t->val) - 1] ) Err(line, col, s_msg); .)
	)
	[
		(. if (bFixed || HasWhitespace()) Err(line, col, s_msg); .)
		"@"
	]
	[ IF (bMixedUnit || IsUnit())
		UnitOrSuffix<0>
		[ NumericExpression<true> ]
	]
.
/*O*/
ObjectName (. ID(L"ObjectName", STMT) .)
=
	[ "#" ]
	MandatoryIdent
.
ObjectStatement<Modifiers *mods> (. ID(L"ObjectStatement", STMT) .)
=
	(.
	mods ? mods->Let(s_Deprecated) : false;
	bool bShared = mods ? mods->Let(s_Shared) : false;
	if (mods) mods->Check();

	int line, col;
	.)
	"Object" (. line = t->line; col = t->col; .)
	ObjectName
	[ IsOrExtendsOrInherits UserType ]
	[ DoesClause ]
	SyncNewline<s_name>
	BlockBody<_Object, line, col, L"OBJECT without END">
.
OptionalArgList (. ID(L"OptionalArgList", STMT) .)
=
	(.
	if (option.args_enclosed && la->kind != _left_paren)
		Err(la->line, la->col, L"Argument list must be between parentheses ('(' ')') because of @OPTION ARGS ENCLOSED");
	.)
	[ ArgumentList ]
.
OptionalNewline (. ID(L"OptionalNewline", STMT) .)
=
	line_break { line_break }
	(.
	// Heuristic to warn about possible missing elements, for example:
	//     foo =
	//     bar = 1 ' Although this line shows as an assignment, it is an equality test.

	if ( la->col <= m_start_col && IsIdentifier(la->kind) ) {
		Warn(la->line, la->col,
			L"Line continuation where the subsequent line starts with a name is not easy to read. "
			L"We recommend that you give such lines more indentation (or use parentheses, if permitted)."
		);
	} .)
.
/*P*/
PassableType (. ID(L"PassableType", STMT) .)
=
	( PrimitiveType | UserType )
	[ Rank ]
.
PowerExpression (. ID(L"Power", EXPR) .)
=
	BitShiftExpression [ "^" PowerExpression ]
.
PrimaryExpression (. ID(L"Primary", EXPR) .)
=
	( char_literal
	| integer_constant
	| NumericExpression<false>
	|
		(. std::wstring s; .)
		StringExpression<s>
	| [ "Class" | "Trait" ]
		Name [ TypeArgumentList ]
	| PrimitiveType
	|
		"(" (. int line = t->line, col = t->col; .)
		EnclosedExpression
		(.
		if (la->kind != _right_paren) {
			if (la->kind != _line_break) Err(la->line, la->col, L"right_paren expected");
			// Try to find the missing paren.
			while (la->kind != _EOF && la->kind != _line_break && la->kind != _right_paren) Get();
			if (la->kind == _right_paren) Get();
			else Err(line, col, L"More left parentheses than right");
		}
		else .) // KLUDGE
		")"
	|
		"If"
		(. Err(L"IF-THEN-ELSE must be between parentheses"); .)
		// Get past most of the garbage. Assumes an otherwise well-formed conditional expression.
		SYNC "Else" PrimaryExpression
	| DivisionFunction
	| "Base"
	| "Self"
	| "#Null"
	|
		malformed_char_literal
		(. SemErr(L"Bad escaped name or character literal - usually caused by missing backtick ('`')"); .)
	|
		malformed_integer_literal
		(. SemErr(L"Bad integer literal"); .)
	|
		malformed_real_literal
		(. SemErr(L"Bad floating-point literal"); .)
	|
		malformed_string_literal
		(. SemErr(L"Bad string literal - usually caused by missing quote(s) ('\"' or '\"\"')"); .)
	)
.
PrimitiveType (. ID(L"PrimitiveType", STMT) .)
=
	(. int kind = la->kind; .)
	(
		"Boolean" | "Char" | "DateTime"
	|
		"Int8"  | "Int16"  | "Int32"  | "Int64"  | "Int128"
	|
		"Real32" | "Real64" | "Real128"
	|
		"String" | "SafeString"  //TODO: Limits on where can use SafeString?
	|
		"UInt8" | "UInt16" | "UInt32" | "UInt64" | "UInt128"
	|
		( "Fixed64" | "Fixed128" )
		[ IF (IsFixedPointArgument())
			"(" integer_literal ")"
		]
	|
		( "SBits" | "UBits" )
		(. if (context.back() != _Struct) SemErr(L"Bit field not permitted here"); .)
		[ "[" PassableType "]" ]
		"(" integer_literal ")"
	)
.
///PropertyOrCall (. ID(PropertyOrCall) .)
///=
///	Name
///	[ IF (IsCall()) EnclosedArgumentList ]
///.
PropertySignature<Modifiers &mods, property_sig &sig> (. ID(L"PropertySignature", STMT) .)
=
	(. bool explicit_array = false; .)
	"Property" (. sig.line = t->line; sig.col = t->col; .)
	[ DimOrVar (. explicit_array = true; .) ]
	(
		[ "Self" ] "!"
		(. if (explicit_array) SemErr(L"Cannot use DIM/VAR with default property"); .)
		(. if (mods.Has(s_WriteOnly)) SemErr(L"Cannot use @WRITEONLY with default property"); .)
		Name
		(. int kind = (_typed_identifier == t->kind) ? _typed_identifier : _Property; .)
		(. if (_typed_identifier == kind) sig.dict_access = true; .)
		EnclosedParameterList<kind>
		[ ReturnTypeClause ]
	| IF (!explicit_array && IsPropertyWithParam())
		Name
		EnclosedParameterList<_Property>
		[ ReturnTypeClause ]
	|
		DeclaratorList
	)
	[ "Does" MandatoryIdent dot MandatoryIdent ]
	SyncNewline<s_name>
.
PropertyStatement<Modifiers &mods> (. ID(L"PropertyStatement", STMT) .)
=
	(.
	#define FLAGS X(Abstract); X(Backed); X(Iterator); X(Open); X(Override); X(ReadOnly); X(Shared); X(WriteOnly);
	#define X _MODS_DECL_FLAGS
	FLAGS
	#undef X
	#define X _MODS_INIT_FLAGS
	if (mods.Count()) {
		mods.Let(s_Deprecated);
		FLAGS
	mods.Check();
	}
	#undef X
	#undef FLAGS

	property_sig sig;
	.)
	PropertySignature<mods, sig>
	[ IF (la->kind == _Get || la->kind == _Set)
		{
			"Get"
			(. if (bWriteOnly) SemErr(L"Cannot have GET with @WriteOnly"); .)
			(
				"=" [OptionalNewline]
				Expression
				SyncNewline<s_name>
			|
				Newline
				(.
				if (bIterator) context.push_back(_Yield);
				context.push_back(_Property);
				.)
				{ Statement }
				(.
				context.pop_back();
				if (bIterator) context.pop_back();
				.)
			)
		|
			"Set"
			(. if (bIterator || bReadOnly) SemErr(L"Cannot have SET with @Iterator or @ReadOnly"); .)
			(. if (sig.dict_access) SemErr(L"Cannot have SET with dictionary access"); .)
			[
				FormalParameterList<_Set>
			] (. else SemErr(L"SET must have one parameter"); .)
			SyncNewline<s_name> 
			(. context.push_back(_Property); .)
			{ Statement }
			(. context.pop_back(); .)
		}
		(. if (la->kind != _End) Err(sig.line, sig.col, L"PROPERTY without END"); .)
		"End"
		(. Optional(_Property); .)
		Newline
	]
.
/*Q*/
QualifiedName<std::wstring &qn, int limit> (. ID(L"QualifiedName", STMT) .)
=
	(. const wchar_t *msg = L"Namespace or type name expected"; .)
	Name
	(.
	qn += t->val;
	if ((limit == _identifier || la->kind == _dot) && t->kind != _identifier) SemErr(msg);
	.)
	{
		dot  (. qn += L'.'; .)
		Name   (. qn += t->val; .)
		(. if (limit == _identifier && t->kind != _identifier) SemErr(msg); .)
	}
.
/*R*/
RaiseStatement (. ID(L"RaiseStatement", STMT) .)
=
	"Raise"
	(
		// Raise event.
		"Event" Name [ ArgumentList ]
	|
		// Raise exception.
		Expression
	|
		// Re-raise exception.
		(.
		if (!in_context(_Catch))
		    SemErr(L"RAISE expression is mandatory here");
		.)
	)
.
Rank (. ID(L"Rank", STMT) .)
=
	"*" integer_literal
.
ReDimClause (. ID(L"ReDimClause", STMT) .)
=
	SimpleNonCallExpression
	"(" EnclosedExpression
	{ comma EnclosedExpression }
	")"
.
ReDimStatement (. ID(L"ReDimStatement", STMT) .)
=
	"ReDim" ReDimClause
	{ comma ReDimClause }
.
RequireComparison (. ID(L"RequireComparison", STMT) .)
=
	// TODO: strings can only be "=" or "<>".
	( [ version_literal ( "<" | "<=" ) ]  // Eg 1.0.0 <= version < 2.0.0
		MandatoryIdent
		ComparisonOperator ( string_literal | version_literal )
	| "(" RequireLogic ")"
	)
.
RequireLogic (. ID(L"RequireLogic", STMT) .)
=
	RequireComparison
	{ ( "And" | "Or" ) RequireComparison }
.
ReturnStatement (. ID(L"ReturnStatement", STMT) .)
=
	"Return" [ Expression ]
.
ReturnTypeClause (. ID(L"ReturnTypeClause", STMT) .)
=
	( AsTypeClause
	| InUnitClause
	)
.
/*S*/
SelectStatement<Modifiers &mods> (. ID(L"SelectStatement", STMT) .)
=
	(.
	bool bStrict   = mods.Let(s_Strict);
	mods.Check();

	int line, col;
	case_type clause = CASE_ZERO;
	.)
	"Select" (. line = t->line; col = t->col; .)
	(. Optional(_Case); .)
	TolExpression
	SyncNewline<s_name>
	(. context.push_back(_Select); .)
	{
		"Case"
		(. if (clause == CASE_ELSE) SemErr(L"CASE cannot follow CASE ELSE in SELECT"); .)
		(
			"Else"
			(. if (clause == CASE_ZERO) SemErr(L"CASE ELSE cannot be first CASE in SELECT"); .)
			(. clause = CASE_ELSE; .)
		|
			ComparisonClause
			{ WEAK comma [OptionalNewline]
				ComparisonClause
			}
			(. clause = CASE_EXPR; .)
		)
		SyncNewline<s_name>
		{ Statement }
	}
	(. context.pop_back(); .)
	(. if (la->kind != _End) Err(line, col, L"SELECT without END"); .)
	"End"
		(. if (clause == CASE_ZERO) SemErr(L"SELECT must have a minimum of one CASE"); .)
		//TODO: if ((bStrict || option.Select_strict != Option::Strict::DEFAULT) ...
	(. Optional(_Select); .)
	Newline
.
SimpleExpression (. ID(L"Simple", EXPR) .)
=
	// Related: IdentifierStatement, SimpleNonCallExpression.
	PrimaryExpression
	{
		[ // Null-conditional operators.
			"?"
			(. if ( HasWhitespace(1) || (_dot != la->kind && _exclamation != la->kind && _left_paren != la->kind) ) {
				Err(L"Bad operator");
			} .)
		]
		( // Member access (eg `obj . member` or `#obj ?. member`).
			"." Name [ TypeArgumentList ]
		| // Dictionary access (eg `obj ! key` or `#obj ?! key`).
			"!" Name
		| // Argument list or array subscript (eg `proc ( args )` or `obj ( indexes )` or `#obj ?( indexes )`).
			EnclosedArgumentList
		)
	}
.
SimpleNonCallExpression (. ID(L"SimpleNonCall", EXPR) .)
=
	// Related: IdentifierStatement, SimpleExpression.
	PrimaryExpression
	{
		[ // Null-conditional operators.
			"?"
			(. if ( HasWhitespace(1) || (_dot != la->kind && _exclamation != la->kind) ) {
				Err(L"Bad operator");
			} .)
		]
		( // Member access (eg `obj . member` or `#obj ?. member`).
			"." Name [ TypeArgumentList ]
		|  // Dictionary access (eg `obj ! key` or `#obj ?! key`).
			"!" Name
		)
	}
.
SimpleStatement (. ID(L"SimpleStatement", STMT) .)
=
	( CallStatement
	| GotoStatement
	| ExitStatement
	| IdentifierStatement
	| RaiseStatement
	| ReDimStatement
	| ReturnStatement
	| YieldStatement
	)
.
SimpleStatementError (. ID(L"SimpleStatementError", STMT) .)
=
	(. Err(la->line, la->col, L"This statement not permitted with one-line IF...ELSE"); .)
	(. Modifiers mods(this); .)
	BlockStatement<mods>
.
Statement (. ID(L"Statement", STMT) .)
=
	(. Modifiers mods(this); .)
	(. m_start_col = la->col; .)
	[ ModifiersClause<mods> ]
	(
		BlockStatement<mods>
	|
		(. mods.Check(); .) // No modifiers.
		SimpleStatement
		{ ";" SimpleStatement }
		SyncNewline<s_name>
	)
.
StringExpression<std::wstring &res> (. ID(L"String", EXPR) .)
=
	(. const std::wstring sep(S_PATH_SEP); .)
	( string_literal | string_constant )
	(. try {
	    res += StringValue(t->val);
	} catch (std::out_of_range &e) {
	    res += L"ERR";
	}
	.)
	{ IF (la->kind == _string_constant || la->kind == _string_literal || la->kind == _slash || la->kind == _backslash)
		[
			"/"
			(. if (option.String_slash == Option::Slash::Back) SemErr(L"Must use backslash because of @OPTION"); .)
			(. res += sep; .)
		|
			"\\"
			(. if (option.String_slash == Option::Slash::Fore) SemErr(L"Must use slash because of @OPTION"); .)
			(. res += sep; .)
		]
		( string_literal | string_constant )
		(. try {
		    res += StringValue(t->val);
		} catch (std::out_of_range &e) {
		    res += L"ERR";
		}
		.)
	}
	///(.
	///if (IsIdentifier(la->kind)) { // TODO: Add other possible incorrect tokens after a string.
		///(. Err(L"Bad string constant. Possibly you want two quotes ('\"\"')."); .)
		///SyncNewline(s_name);
	///}
	///.)
	(. if (args.v >= Args::STMT) wprintf(L"\n[%ls]", res.c_str()); .) //TEMP
.
StructStatement<Modifiers &mods> (. ID(L"StructStatement", STMT) .)
=
	(.
	mods.Let(s_Deprecated);
	bool bMustUse  = mods.Let(s_MustUse);
	mods.Check();

	bool generic = false;
	.)
	"Struct" (. int line = t->line, col = t->col; .)
	MandatoryIdent
	[ TypeParameterList<_Struct> (. generic = true; .) ]
	[ IsOrExtendsOrInherits ( PrimitiveType | UserType ) ]
	[ DoesClause ]
	[ WhereClause<_Struct, generic> ]
	SyncNewline<s_name>
	{ WhereClause<_Struct, generic> SyncNewline<s_name> }
	BlockBody<_Struct, line, col, L"STRUCT without END">
.
SubSignature<Modifiers &mods, int &line, int &col, bool &bGeneric> (. ID(L"SubSignature", STMT) .)
=
	"Sub" (. line = t->line; col = t->col; .)
	Name
	(. bool bReturns = (t->kind == _typed_identifier); .)
	[
		TypeParameterList<_Sub>
		(. bGeneric = true; .)
	]
	[
		EnclosedParameterList<_Sub>
		[
			ReturnTypeClause
			(. bReturns = true; .)
		]
	|
		UnenclosedParameterList<_Sub>
	|
		ReturnTypeClause
		(. bReturns = true; .)
	]
	[
		"Handles"
		(. if (bReturns) SemErr(L"Event handlers cannot have a return type"); .)
		EventSpecifier
		{ comma EventSpecifier }
	]
	[
		WhereClause<_Sub, bGeneric>
	]
	(.
	if (!bReturns && mods.Has(s_Const) || mods.Has(s_MustUse))
		SemErr(L"SUB must have return type because of modifier(s)");
	.)
	SyncNewline<s_name>
.
SubStatement<Modifiers &mods> (. ID(L"SubStatement", STMT) .)
=
	(.
	#define FLAGS X(Const); X(Iterator); X(MustUse); X(Shared);
	#define X _MODS_DECL_FLAGS
	FLAGS
	#undef X
	#define X _MODS_INIT_FLAGS
	if (mods.Count()) {
		mods.Let(s_Deprecated);
		FLAGS
		mods.Let(s_Test);
		mods.Check();
	}
	#undef X
	#undef FLAGS

	int line, col;
	bool bGeneric = false;
	.)
	SubSignature<mods, line, col, bGeneric>
	{
		WhereClause<_Sub, bGeneric>
		SyncNewline<s_name>
	}
	(. if (bIterator) context.push_back(_Yield); .)
	BlockBody<_Sub, line, col, L"SUB without END">
	(. if (bIterator) context.pop_back(); .)
.
SyncNewline<const wchar_t *name> (. ID(L"SyncNewline", STMT) .)
=
	(.
	while (!errors->count // Try this to prevent too many errors.
	    && !(la->kind == _EOF || la->kind == _line_break)) {
		Get();
		Err((std::wstring(L"This symbol not expected in ") + name).c_str());
	}
	.)
	line_break { line_break }
.
SyncSeparator<const wchar_t *name> (. ID(L"SyncSeparator", STMT) .)
=
	(
		SyncNewline<name>
	|
		";" [ SyncNewline<name> ]
	)
.
/*T*/
TolExpression (. ID(L"TolExpr", EXPR) .)
=
	Expression
	[
		"Tol" [ real_literal ]
		[
			LogicalOperator
			(. SemErr(L"Cannot have expression after TOL clause"); .)
			Expression
		]
	]
.
TraitStatement<Modifiers &mods> (. ID(L"TraitStatement", STMT) .)
=
	(. // Permit @MustUse?
	bool bAbstract = mods.Let(s_Abstract);
	mods.Let(s_Deprecated);
	mods.Check();

	bool generic = false;
	.)
	"Trait" (. int line = t->line, col = t->col; .)
	MandatoryIdent
	[ TypeParameterList<_Trait> (. generic = true; .) ]
	[ DoesClause ]
	[ WhereClause<_Trait, generic> ]
	SyncNewline<s_name>
	{ WhereClause<_Trait, generic> SyncNewline<s_name> }
	(. std::array<int, 9> can {{ _at_sign, _Const, _Dim, _Var, _Function, _Method, _Property, _Struct, _Sub }}; .)
	(. context.push_back(_Trait); .)
	{
		(.
		if ( std::find(can.begin(), can.end(), la->kind) == can.end() ) {
			Err(la->line, la->col, L"TRAIT cannot have this statement");
} .)
		Statement
	}
	(. context.pop_back(); .)
	(. if (la->kind != _End) Err(line, col, L"TRAIT without END"); .)
	"End"
	(. Optional(_Trait); .)
	Newline
.
TryStatement (. ID(L"TryStatement", STMT) .)
=
	(. int line, col; .)
	"Try" (. line = t->line; col = t->col; .)
	Newline
	{ Statement }
	{
		"Catch" [ Name [ AsTypeClause ] ] SyncNewline<s_name>
		(. context.push_back(_Catch); .)
		{ Statement }
		(. context.pop_back(); .)
	}
	[
		"Finally" Newline
		(. context.push_back(_Finally); .)
		{ Statement }
		(. context.pop_back(); .)
	]
	(. if (la->kind != _End) Err(line, col, L"TRY without END"); .)
	"End"
	(. Optional(_Try); .)
	Newline
.
TypeArgumentList (. ID(L"TypeArgumentList", STMT) .)
=
	'[' PassableType { WEAK comma PassableType } ']'
.
TypeClause (. ID(L"TypeClause", STMT) .)
=
	( AsTypeClause
	| InUnitClause
	)
.
TypeExpression (. ID(L"Type", EXPR) .)
=
	ConcatenationExpression
	[
		"Is"
		( SimpleNonCallExpression | "Object" )
	|
		"As"
		( PrimitiveType | UserType )
	|
		InUnitClause
	]
.
TypeParameter<int parent> (. ID(L"TypeParameter", STMT) .)
=
	[
		( "In" | "Out" )
		(. if (parent != _Event && parent != _Trait) SemErr(L"IN and OUT are permitted only with EVENT and TRAIT"); .)
	]
	MandatoryIdent
.
TypeParameterList<int parent> (. ID(L"TypeParameterList", STMT) .)
=
	"["
	TypeParameter<parent>
	{ WEAK comma TypeParameter<parent> }
	"]"
.
/*U*/
UnaryExpression (. ID(L"Unary", EXPR) .)
=
	{
		"+"
		(. if (HasWhitespace(1)) Warn(t->line, t->col, L"Whitespace after unary plus ('+') is usually not easy to read"); .)
	|
		"-"
		(. if (HasWhitespace(1)) Warn(t->line, t->col, L"Whitespace after unary minus ('-') is usually not easy to read"); .)
	|
		"Not"
	}
	SimpleExpression
.
UnenclosedArgumentList<int *pCallOrNew> (. ID(L"UnenclosedArgumentList", STMT) .)
=
	(.
	int nBegins = 0;
	if ( _New == context.back()
	|| (pCallOrNew && _Call != *pCallOrNew) ) {
		nBegins = 1; // Can have Begin.
	} .)
	(
		Argument
	|
		comma (. SemErr(L"First argument is missing"); .)
	)
	{ WEAK comma
		( IF (_line_break == la->kind)
			Newline
			(
				(. if (nBegins > 1) Err(la->line, la->col, L"Argument BEGIN must be last one in list"); .)
				Argument
			|
				(.
				if (0 == nBegins) Err(la->line, la->col, L"Cannot use BEGIN in procedure call");
				else if (++nBegins > 2) Err(la->line, la->col, L"Argument BEGIN must be last one in list");
				else if (pCallOrNew) *pCallOrNew = _New;
				.)
				NewBeginStatement
			)
		|
			(. if (nBegins > 1) Err(la->line, la->col, L"Argument BEGIN must be last one in list"); .)
			Argument
		|
			BracketedType
		|
			(. Err(la->line, la->col, L"BEGIN must be on a new line"); .)
			NewBeginStatement
		|
			// Default positional parameter.
		)
	}
	(. if (t->kind == _comma) SemErr(L"Last argument is missing"); .)
.
UnenclosedParameterList<int parent> (. ID(L"UnenclosedParameterList", STMT) .)
=
	(. param_validator param(this, parent); .)
	FormalParameter<param>
	{
		WEAK comma [OptionalNewline]
		FormalParameter<param>
	}
.
UnitAlias (. ID(L"UnitAlias", STMT) .)
=
	(. int number = -1; .)
	[
		integer_literal  // Grammatical number: 1 = singular, 2 = plural, 0 = zero & singular.
		(. if (t->val[0] >= L'0' && t->val[0] <= L'2' && t->val[1] == L'\0') number = t->val[0] - L'0';
		else SemErr(L"Number before unit name must be 0, 1, or 2"); .)
	]
	MandatoryIdent
	[
		( "+" | "-" ) // Plurals by "unit+suffix" or "prefix-unit".
		(. if (number > 0) SemErr(L"Unit name cannot have a plural part after 1 or 2"); .)
		MandatoryIdent
	]
.
UnitOrSuffix<int which> (. ID(L"UnitOrSuffix", EXPR) .)
=
	(
		(.
		bool ws = HasWhitespace();
		.)
		identifier
		(.
		// If possibly a type suffix.
		if (wcschr(L"DdIiRrUu", t->val[0]) && wcschr(L"1368", t->val[1])) {
			if (_Unit == which) {
				Err(L"Bad unit name"); // Possibly only a placeholder.
				return;
			}
			int val = 0;
			for (wchar_t *pch = t->val + 1; *pch; pch++) {
				if (std::iswdigit(*pch) && val <= 128) {
					val = 10 * val + (*pch - L'0');
				} else {
					val = 0; break; // Bad suffix.
				}
			}

			if (val && ws) val = 0; // Suffix cannot have whitespace.

			switch (val) {
			case 8: // i8/u8
				if (! wcschr(L"IiUu", t->val[0])) goto bad_suffix;
				break;
			case 16: // i16/u16
				if (! wcschr(L"IiUu", t->val[0])) goto bad_suffix;
				break;
			case 32: // i32/r32/u32
				if (! wcschr(L"IiRrUu", t->val[0])) goto bad_suffix;
				break;
			case 64: // d64/i64/r64/u64
				break;
			case 128: // d128/i128/r128/u128
				break;
			default:
			bad_suffix:
				Err(L"Bad literal type suffix");
			}
		}
		.)
		(.
		// If incorrectly typed logical operator.
		// Eg: If x = 0 AndThen ...
		// Related code in `LogicalExpression`.
		if (Matches(L"AndThen") || Matches(L"OrElse")) {
			Err(L"Operators AND THEN and OR ELSE must be two words");
			ComparisonExpression(); // `SyncNewline` is possibly better.
		}
		.)
	|
		"("
		MandatoryIdent
		{ [ "*" | "/" ] MandatoryIdent }
		")"
	)
.
UnitStatement<Modifiers &mods> (. ID(L"UnitStatement", STMT) .)
=
	(.
	mods.Let(s_Deprecated);
	bool bSI       = mods.Let(s_SI);
	mods.Check();
	.)
	"Unit" (. int line = t->line, col = t->col; .)
	(. if (context.back() != _Program && context.back() != _Library) SemErr(L"UNIT must be at module level (PROGRAM or LIBRARY)"); .)

	UnitAlias { UnitAlias }
	[
		[ "(" MandatoryIdent InUnitClause ")" ]
		"=" [OptionalNewline]
		Expression // TODO: Constant expression.
	]
	SyncNewline<s_name>
	[ IF (la->kind == _When)
		(. context.push_back(_Unit); .)
		"When" ComparisonClause
		SyncNewline<s_name>
		{ Statement }
		{
			"When" ComparisonClause
			SyncNewline<s_name>
			{ Statement }
		}
		(. context.pop_back(); .)
		(. if (la->kind != _End) Err(line, col, L"UNIT without END"); .)
		"End"
		(. Optional(_Unit); .)
		Newline
	]
.
UserType (. ID(L"UserType", STMT) .)
=
	(. std::wstring name; .)
	QualifiedName<name, _identifier>
	[ TypeArgumentList ]
.
/*V*/
/*W*/
WhenStatement<bool isPreconditional, when_map &whens> (. ID(L"WhenStatement", STMT) .)
=
	"When"
	(
		"Begin"
	|
		identifier
	|
		"Each"
		(. if (option.When_Each_or_Else == TERNARY2) SemErr(L"Must use ELSE because of @OPTION"); .)
	|
		"Else" // Equivalent to "Each".
		(. if (option.When_Each_or_Else == TERNARY1) SemErr(L"Must use EACH because of @OPTION"); .)
	)
	(.
	int kind = t->kind;
	// Change label to upper case.
	wchar_t *val = (t->kind != _Else) ? t->val : L"EACH";
	std::wstring id(val);
	std::transform(id.begin(), id.end(), id.begin(), std::towupper);
	switch ((whens[id] += 2)) {
	case 2: // Label not in Exit When.
		if (option.When_id && kind == _identifier) {
			SemErr(L"WHEN label must be declared at EXIT WHEN because of @OPTION");
		}
		break;
	case 3: // Label in Exit When and When.
		break;
	default: // Duplicate.
		if (kind == _identifier) SemErr(L"Loop cannot have more than one WHEN with the same label");
		else if (kind == _Begin) SemErr(L"Loop cannot have more than one WHEN BEGIN");
		else SemErr(L"Loop cannot have more than one WHEN EACH/ELSE");
		break;
	}
	.)
	Newline
	{ Statement }
.
WhereClause<int block, bool generic> (. ID(L"WhereClause", STMT) .)
=
	"Where"
	(. if (!generic) SemErr(L"WHERE without generic type parameter(s)"); .)
	Constraint<block>
	{
		WEAK comma [OptionalNewline]
		Constraint<block>
	}
.
WhileOrUntil (. ID(L"WhileOrUntil", STMT) .)
=
	( "While"
	| "Until"
	)
.
WhileStatement (. ID(L"WhileStatement", STMT) .)
=
	(. int line, col; .)
	"While" (. line = t->line; col = t->col; .)
	TolExpression
	SyncNewline<s_name>
	(. context.push_back(_While); .)
	[ LoopBody<PRECONDITIONAL> ]
	(. context.pop_back(); .)
	(. if (la->kind != _End) Err(line, col, L"WHILE without END"); .)
	"End"
	(. Optional(_While); .)
	Newline
.
/*X*/
/*Y*/
YieldStatement (. ID(L"YieldStatement", STMT) .)
=
	"Yield"
	(.
	if (!in_context(_Yield))
	    SemErr(L"YIELD without @ITERATOR on procedure");
	if (std::find_if(context.rbegin(), context.rend(),
	    [](int i) { return (_Catch == i || _Finally == i); }) != context.rend())
	    SemErr(L"Cannot use YIELD in CATCH or FINALLY");
	.)
	Expression
.
/*Z*/

END ViviFire.
