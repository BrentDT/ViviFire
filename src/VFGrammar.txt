/*
 * ViviFire Programming Language
 *
 * Copyright 2022 Brent D. Thorn
 *
 * You can get the latest version at http://vivifire.com/.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file.
 */

#include <algorithm>
#include <assert.h>
#include <cstdio>
#include <cwctype>
#include <memory>
#include <map>
#include <string>
#include "Args.h"
#include "AST.h"
#include "Modifier.h"

// IMPORTANT: Use this macro with all productions.
// 'SyncNewline' gets passed 's_name'.
#define ID(sn, iv) \
	static const wchar_t *s_name = sn; \
	if (args.v >= iv) wprintf(L">%ls", s_name);

extern Args args;

COMPILER ViviFire

enum case_type { CASE_ZERO, CASE_EXPR, CASE_ELSE };
enum option_type { OPTION_DEFAULT, WITH_THEN, WITHOUT_THEN };
enum select_type { SELECT_DEFAULT, SELECT_ELSE, SELECT_ELSE_STRING };
enum ternary { TERNARY0, TERNARY1, TERNARY2, YES = TERNARY1, NO = TERNARY2 };
enum { NO_BITS, YES_BITS };
enum { POSTCONDITIONAL, PRECONDITIONAL };

typedef std::map<std::wstring, int> when_map;

struct tag_option {
	Parser*     parser;
	bool        charset_latin   = false;
	ternary     Dim_or_Var      = TERNARY0;
	ternary     End_block       = TERNARY0;
	ternary     End_For_id      = TERNARY0;
	bool        Enum_id         = false;
	bool        Enum_Is         = false;
	bool        Enum_equals     = false;
	ternary     If_Then         = TERNARY0;
	bool        If_End          = false;
	bool        last            = false;
	bool        New             = false;
	bool        Optional_equals = false;
	ternary     Select_Case     = TERNARY0;
	select_type Select_Else     = SELECT_DEFAULT;
	ternary     String_bk_slash = TERNARY0;
	bool        test            = false;
	bool        unit_full       = false;
	short       warning         = 4;
	short       warning_error   = 0;
	ternary     When_Each_Else  = TERNARY0;
	bool        When_id_Begin_id = false;

	bool match(const wchar_t *s) const {
		// Returns true if next token is the same as s, then consumes it.
		if (parser->la->kind != _identifier || _wcsicmp(s, parser->la->val) != 0) return false;
		parser->Get();
		return true;
	}
	bool left_match(const wchar_t *s) const {
		// Returns true if next token starts with s, then consumes it.
		std::unique_ptr<wchar_t> lcval(coco_string_create_lower(parser->la->val));
		if (parser->la->kind != _identifier || wcsstr(lcval.get(), s) != lcval.get()) return false;
		parser->Get();
		return true;
	}
	void option_error() const {
		parser->SemErr(L"Unknown or missing option");
	}
	void optional_no(int kind, const wchar_t *id = nullptr) const {
		// Test for optional "No" plus token.
		if (match(L"no")) {
			if (parser->la->kind == kind) {
				if (_identifier == kind) match(id);
				else parser->Get();
				return;
			}
			option_error();
		}
	}

	void Parse() {
		static const wchar_t *s_block = L"block", *s_equals = L"equals", *s_id = L"id", *s_warning = L"warning";
		if (last) parser->SemErr(L"@OPTION not permitted after LAST");
		parser->Get();
		switch (parser->la->kind) {
		case _Dim:
			parser->Get();
			Dim_or_Var = TERNARY1;      // @Option Dim
			break;
		case _Var:
			parser->Get();
			Dim_or_Var = TERNARY2; // @Option Var
			break;
		case _End:
			parser->Get();
			if (_For == parser->la->kind) { // End For
				parser->Get();
				optional_no(_identifier, s_id);
				End_For_id = NO; // @Option End For [ no id ]
			} else if (match(s_block)) {
				End_block = YES; // @Option End Block
			} else {
				optional_no(_identifier, s_block);
				End_block = NO; // @Option End [ No Block ]
			}
			break;
		case _Enum:
			parser->Get();
			if (match(s_id)) {
				Enum_id = true;           // @Option Enum ID
			} else if (parser->la->kind == _Is) {
				parser->Get();
				Enum_Is = true;  // @Option Enum Is
			} else if (match(s_equals)) {
				Enum_equals = true; // @Option Enum Equals
			} else goto bad_option;
			break;
		case _If:
			parser->Get();
			if (_End == parser->la->kind) {
				parser->Get();
				If_End = true; // @Option If End
			} else if (_Then == parser->la->kind) {
				parser->Get();
				If_Then = YES;                    // @Option If Then
			} else {
				optional_no(_Then);
				If_Then = NO; // @Option If [ No Then ]
			}
			break;
		case _New:
			parser->Get();
			New = true; // @Option New
			break;
		case _Optional:
			parser->Get();
			if (match(s_equals)) {
				Optional_equals = true; // @Option Optional Equals
			} else goto bad_option;
			break;
		case _Select:
			parser->Get();
			if (_Else == parser->la->kind) {
				parser->Get();
				if (_String == parser->la->kind) {
					parser->Get();
					Select_Else = SELECT_ELSE_STRING; // @Option SELECT ELSE STRING
				} else {
					Select_Else = SELECT_ELSE; // @Option SELECT ELSE
				}
			} else if (_Case == parser->la->kind) {
				parser->Get();
				Select_Case = YES;                      // @Option SELECT CASE
			} else {
				optional_no(_Case);
				Select_Case = NO; // @Option Select [ No Case ]
			}
			break;
		case _String:
			parser->Get();
			if (match(L"backslash")) {
				String_bk_slash = TERNARY1; // @Option String Backslash
			}else if (match(L"slash")) {
				String_bk_slash = TERNARY2; // @Option String Slash
			} else goto bad_option;
			break;
		case _Unit:
			parser->Get();
			if (match(L"full")) {
				unit_full = true; // @Option Unit Full
			} else goto bad_option;
			break;
		case _When:
			parser->Get();
			if (_Each == parser->la->kind) {
				parser->Get();
				When_Each_Else = TERNARY1; // @Option When Each
			} else if (_Else == parser->la->kind) {
				parser->Get();
				When_Each_Else = TERNARY2; // @Option When Else
			} else if (match(s_id) && _Begin == parser->la->kind) {
				parser->Get();
				if (match(s_id)) {
					When_id_Begin_id = true; // @Option When ID Begin ID
				} else goto bad_option;
			} else goto bad_option;
			break;
		case _identifier:
			// For each addition, remember to "break" when correct.
			if (match(L"last")) {
				last = true; // @Option Last
				break;
			} else if (match(L"test")) {
				test = true; // @Option Test
				break;
			} else if (left_match(s_warning)) {
				short level = (short)parser->t->val[coco_string_length(s_warning)]; // Valid: '\0', '1', '2', '3', '4', & '5'.
				if (level == 0) {
					level = L'4'; // Default is 4.
				} else if (level < L'1' || level > L'5') goto bad_option;
				level -= L'0';
				if (match(L"error")) {
					warning_error = level; // @Option Warning[1-5] Error
					break;
				} else {
					warning = level; // @Option Warning[1-5]
					break;
				}
			}
			// Fall through for error
		default:
		bad_option:
			parser->Get();
			option_error();
			break;
		}
		if (parser->la->kind != _line_break && parser->la->kind != _EOF) goto bad_option;
	}

} option = { /* parser */ this };

class param_type {
	Parser *m_parser;
	int m_parent;
	bool m_byref = false;
	int m_optionals = 0;
public:
	param_type(Parser *parser, int parent): m_parser(parser), m_parent(parent) {}
	void modifier(int kind = -1) {
		switch (kind) {
		case -1:
			m_byref = false;  // by value
			break;
		case _ByRef:
			if (m_optionals) m_parser->SemErr(L"Optional parameter cannot be BYREF");
			else m_byref = true;
			break;
		case _Optional:
			if (m_optionals == 1) m_parser->Warn(L"OPTIONAL is not necessary again");
			else m_optionals++;
			break;
		default:
			#if defined(DEBUG)
			m_parser->errors->Exception(L"Bad kind in param_type::modifier");
			#endif
			break;
		}
	}
	bool optional() const { return (m_optionals != 0); }
};

void Err(const wchar_t *msg) {
	errors->Error(t->line, t->col, msg);
}

void Err(int line, int col, const wchar_t *msg) {
	errors->Error(line, col, msg);
}

void Warn(const wchar_t *msg) {
	// TODO: warning levels.
	if (option.warning_error) Err(msg);
	else errors->Warning(msg);
}

void Warn(int line, int col, const wchar_t *msg) {
	// TODO: warning levels.
	if (option.warning_error) Err(line, col, msg);
	else errors->Warning(line, col, msg);
}

void Optional(int kind, option_type nOption = OPTION_DEFAULT) {
	switch (kind) {
	case _Case:  // Select [ Case ]
		if (la->kind == _Case) {
			Get();
			if (option.Select_Case == NO) SemErr(L"SELECT cannot have CASE because of @OPTION");
		}
		else if (option.Select_Case == YES) SemErr(L"SELECT must have CASE because of @OPTION");
		break;
	case _Class:        // End [ Class ]
	case _Constructor:  // End [ Constructor ]
	case _Declare:      // End [ Declare ]
	case _Destructor:   // End [ Destructor ]
	case _Enum:         // End [ Enum ]
	case _Function:     // End [ Function ]
	case _If:           // End [ If ]
	case _Method:       // End [ Method ]
	case _Namespace:    // End [ Namespace ]
	case _Object:       // End [ Object ]
	case _Property:     // End [ Property ]
	case _Select:       // End [ Select ]
	case _Struct:       // End [ Struct ]
	case _Sub:          // End [ Sub ]
	case _Trait:        // End [ Trait ]
	case _Try:          // End [ Try ]
	case _While:  // End [ While ]
		if (la->kind == _line_break) { // END without block type.
			if (option.End_block == YES) SemErr(L"END must have block type because of @OPTION");
		} else { // END with block type.
			if (option.End_block == NO) {
				Get();
				SemErr(L"END cannot have block type because of @OPTION");
			} else if (la->kind != kind) { // Incorrect block type.
				Expect(kind);
			} else {
				Get();
			}
		}
		break;
	case _For:  // End [ For [ name ] ]
		if (la->kind == _For) {
			Get();
			if (option.End_block == NO) SemErr(L"END cannot have block type because of @OPTION");
			if (IsIdentifier(la->kind)) {
				Name();
				if (option.End_For_id == NO) SemErr(L"END FOR cannot have name because of @OPTION");
			}
			else if (option.End_For_id == YES) SemErr(L"END FOR must have name because of @OPTION");
		}
		//TODO: else if (end_block)
		break;
	case _Then:
		if (nOption == OPTION_DEFAULT && la->kind == _Then) {
			nOption = WITH_THEN;
			Get();
		}
		if (nOption == WITH_THEN && option.If_Then == NO)
			SemErr(L"IF cannot have THEN because of @OPTION");
		else if (nOption == WITHOUT_THEN && option.If_Then == YES)
			SemErr(L"IF must have THEN because of @OPTION");
		break;
	default:
		#if defined(DEBUG)
		errors->Exception(L"Bad kind in Optional");
		#endif
		break;
	}
}

int cc_depth, cc_exec;

void CCInit() {
	cc_depth = cc_exec = 0;
}

void CCGet() {
	delete t;
	t = la;
	la = scanner->Scan();
}

bool CCTest() {
return false; // FIXME: temporary
	if (la->kind == _Not) {
		CCGet();
	}
	if (la->kind != _identifier) SynErr(_identifier);
	// test it
	CCGet();
}

void CCEval() {
	if (t->kind != _line_break) SemErr(L"Compiler directive must start a line");

	switch (la->kind) {
	case _atIf: {
		bool test = false;
		CCGet();
		test = CCTest();
		while (la->kind == _And || la->kind == _Or) {
			CCGet();
			if (t->kind == _And)
				test &= CCTest();
			else
				test |= CCTest();
		}
		if (la->kind == _Then) CCGet();
		if (la->kind != _line_break) SynErr(_line_break);
		cc_depth++;
		if (test) cc_exec = cc_depth;
		break;
	}
	case _atElse:
		if (cc_exec == cc_depth - 1) cc_exec++;
		break;
	case _atEnd:
		if (cc_depth > 0) cc_depth--; else SemErr(L"@END IF without @IF");
		if (cc_exec > cc_depth) cc_exec = cc_depth;
		break;
	}

	if (cc_exec == cc_depth) {
		while (la->kind < _atError) CCGet();
	}
}

void ParseInlineComment() {
	// Parse out "expect-error {{msg}}" or "expect-warning {{msg}}".
	wchar_t *p = la->val;

		// Move past "'" or "//", and whitespace.
	while (*p == L'/' || *p == L'\'' || *p == 32 || *p == 9 || *p == 160) p++;

	// Find "expect-".
	if (wcsncmp(p, L"expect-", 7)) return;
	p += 7;

	// Find "error" or "warning".
	bool bError = true;
	if (wcsncmp(p, L"error", 5) == 0) {
		p += 5;
	} else if (wcsncmp(p, L"warning", 7) == 0) {
		p += 7; bError = false;
	} else return;

	// Whitespace again.
	while (*p == 32 || *p == 9 || *p == 160) p++;

	// Find "{{".
	if (p[0] != L'{' && p[1] != L'{') return; // FIXME: Should this be an error?
	p += 2;

	// Find "}}".
	wchar_t *pRight = wcsstr(p, L"}}");
	if (pRight == nullptr) return; // FIXME: Should this be an error?

	if (bError) {
		Warn(L"Expecting an error"); // TEMP
	} else {
		Warn(L"Expecting a warning"); // TEMP
	}
}

const wchar_t *SIGILS = L"%!$@";

// Resolvers

bool IsAssignmentOp() {
	switch (la->kind) {
	case _concatenation: case _plus: case _minus: case _asterisk: case _slash:
	case _Mod: case _Rem: case _SHL: case _SHR: case _And: case _Or: case _Xor:
		if (scanner->Peek()->kind != _equals) return false;
	case _equals: case _colon_equals:
		return true;
	}
	return false;
}

///bool IsCall() {
///	// Disambiguate "("[args]")" from "("["Is"]("<"|"<="|">"|">="|"<>"|"=")")".
///	if (la->kind == _left_paren) {
///		int first = scanner->Peek()->kind;
///		if (first == _Is || (first >= _less_than && first <= _equals)) return false;
///		return true;
///	}
///	return false;
///}

bool IsDeclareParameterList() {
	if (la->kind == _left_paren) {
		int k = scanner->Peek()->kind;
		if (k == _line_break) k = scanner->Peek()->kind;
		if (k == _Optional) k = scanner->Peek()->kind;
		return (k == _integer_literal);
	}
	return false;
}

bool IsFixedPointArgument() {
	return (la->kind == _left_paren && scanner->Peek()->kind == _integer_literal);
}

bool IsIdentifier(int kind) {
	return (kind == _identifier || kind == _typed_identifier || kind == _nullable_identifier);
}

bool IsNamedArgument() {
	return (IsIdentifier(la->kind) && scanner->Peek()->kind == _colon_equals);
}

///bool IsNewStatement() {
///	if (la->kind == _New) return true;
///	if (la->kind == _identifier) { // FIXME: could be qualified name
///		int next = scanner->Peek()->kind;
///		return (next == _nullable_identifier || next == _left_bracket); // FIXME: nullable not necessary
///	}
///	return false;
///}

bool IsPropertySelf() {
	// "Self", "Self%", "Self!", "Self$", or "Self@".
	if (la->kind == _Self) return true;
	if (la->kind == _typed_identifier && _wcsnicmp(L"self", la->val, 4) == 0 && wcschr(SIGILS, la->val[4])) {
		return true;
	}
	return false;
}

bool IsPropertyWithParam() {
	return (IsIdentifier(la->kind) && scanner->Peek()->kind == _left_paren && IsIdentifier(scanner->Peek()->kind));
	// FIXME: Possible param modifier?
}

bool IsUnit() {
	if (la->kind == _identifier) return true;
	if (la->kind == _left_paren && scanner->Peek()->kind == _identifier) return true;
	return false;
}

bool IsUnorderedInit() {
	int k = la->kind;
	return ((k == _char_literal || k == _integer_constant || k == _integer_literal) && scanner->Peek()->kind == _colon_equals);
}

///void ExpectEndNew(const wchar_t *tn) {
///	if (la->kind == _End) {
///		Get();
///		if (tn == NULL && la->kind != _New) {
///			Err(L"End New expected");
///			return;
///		}
///		else if (tn != NULL && wcscmp(tn, la->val) != 0) {
///			Err(L"End %ls expected"); // FIXME: show ident
///			return;
///		}
///	}
///	Get();
///}

IGNORECASE

CHARACTERS

// Single characters

n = '\n'.
r = '\r'.
t = '\t'.

// Character sets

ctrl = '\u0000' .. '\u001f'.
eol = n + r.
notEOL = ANY - ctrl - eol.

alpha = 'A' .. 'Z'.
alnum = alpha + '0' .. '9'.
sigil = "!$%@".

bin = "01".
dec = '0' .. '9'.
hex = '0' .. '9' + 'A' .. 'F'.
oct = '0' .. '7'.

nonbin = alnum - bin.
nonhex = alnum - hex.
nonoct = alnum - oct.

currency = ANY - dec - "_" - ctrl.

str = ANY - ctrl - eol - '"'.
char = ANY - ctrl - eol.

TOKENS

line_break  = eol{eol}.

comma       = ",".
dot         = ".".
exclamation = "!".
question    =  "?".

// Primary
left_paren    = "(".
right_paren   = ")".
left_bracket  = "[".
right_bracket = "]".
left_brace    = "{".
right_brace   = "}".
backslash     = "\\".

// Unary
plus  = "+".
minus = "-".

// Arithmetic
caret    = "^".
asterisk = "*".
slash    = "/".

// Concatenation
concatenation =
	( "&"
	// Prevent misparsing as binary, hexadecimal, or octal integer.
	| "&" CONTEXT ( ("B"{bin}nonbin) | ("H"{hex}nonhex) | ("O"{oct}nonoct) )
	).

// Null coalescing
null_coalescing = "|?".

// Comparison
tilde            = "~".
less_than        = "<".
less_or_equal    = "<=".
greater_than     = ">".
greater_or_equal = ">=".
not_equal        = "<>".
equals           = "=".

// Assignment
colon_equals = ":=".

// Literals

char_literal =
	'`'char'`'.

malformed_char_literal =
	'`'[char].

date_literal =
	dec{dec}
	( "/"dec{dec}"/"dec{dec}  // yyyy/mm/dd
	| "-"dec{dec}"-"dec{dec}  // yyyy-mm-dd
	).

//TODO: malformed_date_literal

fixed_literal =
	( '¤' | '@'[currency] )
	dec{['_']dec}['.'dec{dec}].

malformed_fixed_literal =
	( ('¤'|'@'currency)[dec{dec|'_'}('_'|'.')]
	| '@'[currency]dec{dec|'_'}("__"|".."){dec|'_'}
	).

integer_constant =
	'%'alpha{['_']alnum}.

integer_literal =
	( "&B"bin{['_']bin}
	| "&O"oct{['_']oct}
	| "&H"hex{['_']hex}
	| dec{['_']dec}
	// Prevent misparsing units (eg "312electronvolts") as real_literal.
	| dec{['_']dec} CONTEXT ("E"alpha)
	).

malformed_integer_literal =
	( "&B"bin{bin|'_'}"__"{bin|'_'}
	| "&O"oct{oct|'_'}"__"{oct|'_'}
	| "&H"hex{hex|'_'}"__"{hex|'_'}
	| dec{dec|'_'}"__"{dec|'_'}
	).

null_literal =
	'|'{'-'}.

real_literal =
	( [dec{['_']dec}]'.'dec{['_']dec}['E'['+'|'-']dec{dec}]['!']
	| dec{['_']dec}'E'['+'|'-']dec{dec}['!']
	| dec{['_']dec}'!'
	).

malformed_real_literal =
	( dec{dec|'_'}"__"{dec|'_'}'.'{'.'}{dec|'_'}['E'['+'|'-']{dec}]['!']
	| {dec|'_'}'.'{'.'}dec{dec|'_'}"__"{dec|'_'}['E'['+'|'-']{dec}]['!']
	| dec{dec|'_'}"__"{dec|'_'}'!'
	).

string_constant =
	'$'alnum{['_']alnum}.

string_literal =
	['_']          // continuation
	'"'{str}'"'    // normal string
	{ ///['/'|'\\']   // path string
	  '"'{str}'"'  // double quotes
	}.

malformed_string_literal =
	['_']'"'{str}{'"'/*['/'|'\\']*/'"'{str}}/*['"'('/'|'\\')]*/.

time_literal =
	dec{dec}":"dec{dec}[":"dec{dec}["."dec{dec}]].

//TODO: malformed_time_literal

version_literal =
	dec{dec}"."dec{dec}"."dec{dec}["."dec{dec}].

//TODO: malformed_version_literal

// Identifiers

identifier =
	( alpha{["_"]alnum}
	// Use keywords, eg `Class`
	| "`"alpha alnum{alnum}"`"
	// Prevent misparsing "obj!name" as typed_identifier.
	| alpha{["_"]alnum} CONTEXT ("!"alpha)
	).

nullable_identifier =
	( "#"alnum{["_"]alnum}
	// Prevent misparsing "#obj!name" as typed_identifier.
	| "#"alnum{["_"]alnum} CONTEXT ("!"alpha)
	).

typed_identifier =
	(alpha|"#"){["_"]alnum}sigil.

// Keywords

And         = "And".
As          = "As".
Base        = "Base".
Begin       = "Begin".
Boolean     = "Boolean".
ByRef       = "ByRef".
Call        = "Call".
Case        = "Case".
Catch       = "Catch".
Char        = "Char".
Class       = "Class".
Const       = "Const".
Constructor = "Constructor".
DateTime        = "DateTime".
Declare     = "Declare".
Destructor  = "Destructor".
Dim         = "Dim".
Do          = "Do".
Does        = "Does".
Each        = "Each".
Else        = "Else".
End         = "End".
Enum        = "Enum".
Event       = "Event".
Exit        = "Exit".
Finally     = "Finally".
Fixed64     = "Fixed64".
Fixed128    = "Fixed128".
For         = "For".
Function    = "Function".
Get         = "Get".
GoTo        = "GoTo".
Handles     = "Handles".
If          = "If".
In          = "In".
Int         = "Int".
Int8        = "Int8".
Int16       = "Int16".
Int32       = "Int32".
Int64       = "Int64".
Int128      = "Int128".
Is          = "Is".
Let         = "Let".
Library     = "Library".
Loop        = "Loop".
Method      = "Method".
Mod         = "Mod".
Namespace   = "Namespace".
New         = "New".
Not         = "Not".
Object      = "Object".
Optional    = "Optional".
Or          = "Or".
Out         = "Out".
Program     = "Program".
Property    = "Property".
Raise       = "Raise".
Real        = "Real".
Real32      = "Real32".
Real64      = "Real64".
Real128     = "Real128".
ReDim       = "ReDim".
Rem         = "Rem".
Require     = "Require".
Return      = "Return".
SafeString  = "SafeString".
SBits       = "SBits".
Select      = "Select".
Self        = "Self".
Set         = "Set".
SHL         = "SHL".
SHR         = "SHR".
Step        = "Step".
String      = "String".
Struct      = "Struct".
Sub         = "Sub".
Then        = "Then".
To          = "To".
Tol         = "Tol".
Trait       = "Trait".
Try         = "Try".
UBits       = "UBits".
UInt        = "UInt".
UInt8       = "UInt8".
UInt16      = "UInt16".
UInt32      = "UInt32".
UInt64      = "UInt64".
UInt128     = "UInt128".
Unit        = "Unit".
Until       = "Until".
Var         = "Var".
When        = "When".
Where       = "Where".
While       = "While".
Xor         = "Xor".
Yield       = "Yield".

PRAGMAS

LineContinuation = '_'{notEOL}eol[n].

// Directives

atOption = "@Option". (. option.Parse(); .)
atError  = "@Error". (.
	int l = la->line, c = la->col;
	Get();
	if (la->kind == _string_literal) {
		Get();
		Err(l, c, t->val);
	} else SynErr(_string_literal); .)
atWarn   = "@Warn". (.
	Get();
	if (la->kind == _string_literal) {
		Get();
		Warn(t->val);
	} else SynErr(_string_literal); .)

// Conditional compilation

atIf   = "@If".    (. CCEval(); .)
atElse = "@Else".  (. CCEval(); .)
atEnd  = "@End".   (. CCEval(); .)

// Comments

InlineComment = ("'"|"//"){notEOL}. (.
	if (option.test) ParseInlineComment(); .)

COMMENTS FROM "/*" TO "*/" NESTED  // C-style
COMMENTS FROM "/'" TO "'/" NESTED

IGNORE t + '\u00a0' // non-breaking space

PRODUCTIONS

ViviFire (. ID(L"ViviFire", 3) .)
=
	Module

	// Catch errors in block statements.
	[ "Case"         (. SemErr(L"CASE without SELECT"); .)
	| "Catch"        (. SemErr(L"CATCH without TRY"); .)
	| "Constructor"  (. SemErr(L"CONSTRUCTOR without CLASS"); .)
	| "Destructor"   (. SemErr(L"DESTRUCTOR without CLASS"); .)
	| "Get"          (. SemErr(L"GET without PROPERTY"); .)
	| "Else"         (. SemErr(L"ELSE without IF"); .)
	| "End"          (. SemErr(L"END without start"); .)
	| "Finally"      (. SemErr(L"FINALLY without TRY"); .)
	| "Loop"         (. SemErr(L"LOOP without DO"); .)
	| "Rem"          (. SemErr(L"REM is not a comment. Try ' or //"); .)
	| "Set"          (. SemErr(L"SET without PROPERTY"); .)
	| "Then"         (. SemErr(L"THEN without IF"); .)
	| "Until"        (. SemErr(L"UNTIL without DO or LOOP"); .)
	| "When"         (. SemErr(L"WHEN without BEGIN"); .)
	| ConstantValueError
	]

	EOF

	(. wprintf(L"\n-- %d %ls\n", errors->count, (errors->count == 1) ? L"error" : L"errors"); .)
.

/*A*/
AdditiveExpression (. ID(L"Additive", 2) .)
=
	MultiplicativeExpression { ( '+' | '-' ) MultiplicativeExpression }
.
Argument (. ID(L"Argument", 3) .)
=
	( null_literal
	| [ IF (IsNamedArgument()) Name ":=" ]
	  EnclosedExpression
	)
	// If non-decimal integer ("&b...", "&h...", or "&o...")
	(. if (la->kind == _integer_literal && la->val[0] == L'&') {
		Warn(la->line, la->col, L"Possibly argument list has missing comma");
	} .)
.
ArgumentList (. ID(L"ArgumentList", 3) .)
=
	// Disambiguate "("args")" from "("expr")".
	( IF (la->kind == _left_paren) EnclosedArgumentList
	| UnenclosedArgumentList
	)
.
ArrayDimensionList (. ID(L"ArrayDimensionList", 3) .)
=
	'('
	[ Rank                             // Eg 'Dim matrix(*2)'
	| Expression { comma Expression }  // Eg 'Dim matrix(3, 3)'
	]
	')'
.
AssignmentOperator (. ID(L"AssignmentOperator", 3) .)
=
	[ concatenation | "+" | "-" | "*" | "/" | "Mod" | "Rem" | "SHL" | "SHR" | "And" | "Or" | "Xor" ]
	"="
.
AssignmentStatement (. ID(L"AssignmentStatement", 3) .)
=
	( AssignmentOperator[line_break] Expression
	| ":=" Expression { ":=" Expression }
	)
.
AsTypeClause<bool bBits> (. ID(L"AsTypeClause", 3) .)
=
	"As"
	( UserType [ EnclosedArgumentList ]
	| PrimitiveType<bBits>
	)
	[ Rank ]
.
/*B*/
BaseUnitStatement<class Modif &mods> (. ID(L"BaseUnitStatement", 3) .)
=
	(.
	mods.allow(Modif::Deprecated);
	mods.validate();
	.)
	"Base"
	( "Unit" identifier InUnitClause
		[ "=" MultiplicativeExpression ]
		SyncNewline<s_name>
	| ANY (. SemErr(L"Object BASE is available only in a child class"); .)
	)
.
BitFieldType<int &tkn> (. ID(L"BitFieldType", 3) .)
=
	(. tkn = la->kind; .)
	( "SBits" | "UBits" ) "(" integer_literal ")"
.
BitShiftExpression (. ID(L"BitShift", 2) .)
=
	UnaryExpression { ( "SHL" | "SHR" ) UnaryExpression }
.
Block<int &tkn> (. ID(L"Block", 3) .)
=
	(. tkn = la->kind; .)
	( "Do" | "For" | "Function" | "Method" | "Property" | "Sub" | "While" )
.
BlockStatement (. ID(L"BlockStatement", 3) .)
=
	( DimStatement<nullptr>
	| NewStatement<nullptr>
	| EventStatement
	| DoStatement
	| ForStatement
	| IfStatement
	| SelectStatement
	| TryStatement
	| WhileStatement
	)
.
/*C*/
CallOrNew<int which, Modif *mods> (. ID(L"CallOrNew", 3) .)
=
	(.
	bool bShared = mods ? mods->allow(Modif::Shared) : false;
	if (mods) mods->validate();
	.)
	UnenclosedArgumentList
	[ IF (la->kind == _line_break && scanner->Peek()->kind == _Begin) // FIXME: multiple line breaks?
		SyncNewline<s_name>
		NewBlockStatement
	]
.
CallStatement (. ID(L"CallStatement", 3) .)
=
	"Call"
	( QualifiedName<0>
	| "Base"
	| "Constructor"
	)
	[ ArgumentList ]
.
CaseClause<case_type &clause> (. ID(L"CaseClause", 3) .)
=
	"Case"
		(. if (clause == CASE_ELSE) SemErr(L"CASE cannot follow CASE ELSE in SELECT"); .)
	( "Else"
		(. if (clause == CASE_ZERO) SemErr(L"CASE ELSE cannot be first CASE in SELECT"); .)
		(. clause = CASE_ELSE; .)
	| CaseExpression { WEAK comma[line_break] CaseExpression }
		(. clause = CASE_EXPR; .)
	)
	SyncNewline<s_name>
	{ Statement }
.
CaseExpression (. ID(L"CaseExpression", 3) .)
=
	( "Is" ComparisonOperator Expression
	| Expression [ "To" Expression ]
	)
.
CatchClause (. ID(L"CatchClause", 3) .)
=
	"Catch" [ Name [ AsTypeClause<NO_BITS> ] ] SyncNewline<s_name>
	{ Statement }
.
ClassOrObjectMember<int kind> (. ID(L"ClassOrObjectMember", 3) .)
=
	(. Modif mods(this); .)
	[ ModifiersClause<mods> ]
	(
		 (. if (kind == _Object) Err(la->line, la->col, L"OBJECT cannot have CONSTRUCTOR"); .)
		ConstructorStatement<mods>
	|
		(. if (kind == _Object) Err(la->line, la->col, L"OBJECT cannot have DESTRUCTOR"); .)
		DestructorStatement<mods>
	| ConstStatement<mods>
	| DimStatement<&mods>
	| EnumStatement<mods>
	| EventStatement
	| FunctionStatement<mods>
	| MethodStatement<mods>
	| NewStatement<&mods>
	| PropertyStatement<mods>
	| StructStatement<mods>
	| SubStatement<mods>
	)
.
ClassStatement<Modif &mods> (. ID(L"ClassStatement", 3) .)
=
	(.
	bool bAbstract = mods.allow(Modif::Abstract);
	mods.allow(Modif::Deprecated);
	bool bOpen = mods.allow(Modif::Open);
	mods.validate();

	bool generic = false;
	.)
	"Class" identifier
	[ TypeParameterList<_Class> (. generic = true; .) ]
	[ "Is" UserType ]
	{ DoesClause }
	[ WhereClause<_Class, generic> ]
	SyncNewline<s_name>
	{ WhereClause<_Class, generic> SyncNewline<s_name> }
//	{ Statement } // Conflict: assignment vs var decl
	{ ClassOrObjectMember<_Class> }
	"End"
	(. Optional(_Class); .)
	Newline
.
ComparisonExpression (. ID(L"Comparison", 2) .)
=
	NullCoalescingExpression { ComparisonOperator NullCoalescingExpression }
.
ComparisonOperator (. ID(L"ComparisonOperator", 3) .)
=
	[ "~" ]
	( "=" | "<>" | "<" | "<=" | ">" | ">=" )
.
ConcatenationExpression (. ID(L"Concatenation", 2) .)
=
	AdditiveExpression
	{ concatenation AdditiveExpression }
	// If non-decimal integer ("&b...", "&h...", or "&o...")
	(. if (la->kind == _integer_literal && la->val[0] == L'&') {
		std::unique_ptr<wchar_t> msg(coco_string_create_append(L"Possibly concatenation is incorrectly written as integer literal: ", la->val));
		Warn(la->line, la->col, msg.get());
	} .)
.
///ConditionalComparison (. ID(ConditionalComparison) .)
///=
///	ComparisonOperator "Is" NullCoalescingExpression
///.
ConditionalExpression (. ID(L"Conditional", 2) .)
=
	( EnclosedExpression
	| "If" EnclosedExpression
		( "Then" EnclosedExpression "Else" EnclosedExpression
///		| "<=>" NullCoalescingExpression ConditionalComparison { ConditionalComparison }
		)
	)
.
ConstantDeclarator (. ID(L"ConstantDeclarator", 3) .)
=
	identifier [ TypeClause<NO_BITS> ] "=" Expression
.
ConstantValueError (. ID(L"ConstantValueError", 3) .)
=
	( char_literal | date_literal | fixed_literal | integer_constant | integer_literal | null_literal
	| real_literal | string_constant | string_literal | time_literal | version_literal
	)
	(. SemErr(L"Cannot use a constant value here"); .)
.
ConstStatement<Modif &mods> (. ID(L"ConstStatement", 3) .)
=
	(.
	mods.allow(Modif::Deprecated);
	mods.validate();
	.)
	"Const" ConstantDeclarator { WEAK comma ConstantDeclarator }
	SyncNewline<s_name>
.
Constraint<int block> (. ID(L"Constraint", 3) .)
=
	(
		(. int c = 0; .)

		identifier
		[ (. c++; .)
			( "<" | "<=" ) identifier [ ( "<" | "<=" ) identifier ]
		]
		[ (. c++; .)
			"Is" ( "Class" | "Struct" | "Unit" )
		]
		{ (. c++; .)
			"Does" UserType
		}
		[ (. c++; .)
			"Constructor" ( "(" ")" | "?" )
		]
		(. if (c == 0) SemErr(L"invalid Constraint"); .)
	|
		"Self"
		(. if (block != _Class && block != _Trait) SemErr(L"SELF constraint only available in CLASS and TRAIT"); .)
		( "<" | "<=" | "Is" )
		UserType
	)
.
ConstructorStatement<Modif &mods> (. ID(L"ConstructorStatement", 3) .)
=
	(.
	mods.allow(Modif::Deprecated);
	mods.validate();
	.)
	"Constructor"
	[ FormalParameterList<_Constructor> | DimOrVar ]
	SyncNewline<s_name>
	{ Statement }
	"End"
	(. Optional(_Constructor); .)
	Newline
.
ConvertibleType (. ID(L"ConvertibleType", 3) .)
=
	( PrimitiveType<NO_BITS> | UserType )
.
/*D*/
DateTimeExpression (. ID(L"DateTime", 2) .)
=
	( date_literal [ time_literal ]
	| time_literal
	)
.
Declarator<bool bBits> (. ID(L"Declarator", 3) .)
=
	Name
	[ ArrayDimensionList ]
	[ TypeClause<bBits> ]
	[ '=' InitializationExpression ]
.
DeclaratorList<bool bBits> (. ID(L"DeclaratorList", 3) .)
=
	Declarator<bBits> { WEAK comma[line_break] Declarator<bBits> }
.
DeclareParameter<bool &isOptional> (. ID(L"DeclareParameter", 3) .)
=
	[ "Optional" (. isOptional = true; .) ]
	integer_literal
	[ "=" EnclosedExpression ]
.
DeclareParameterList (. ID(L"DeclareParameterList", 3) .)
=
	(. bool isOptional; .)
	( IF (IsDeclareParameterList())
		"("[line_break]
		[ DeclareParameter<isOptional> { WEAK comma[line_break] DeclareParameter<isOptional> } ]
		")"
	| EnclosedParameterList<_Declare> [ TypeClause<NO_BITS> ]
	)
.
DeclareSignature<bool isAlias> (. ID(L"DeclareSignature", 3) .)
=
	( "Function" | "Sub" )
	Name
	[ "Is" ( string_literal | QualifiedName<0> ) ]
	[ DeclareParameterList ]
.
DeclareStatement<Modif &mods> (. ID(L"DeclareStatement", 3) .)
=
	(.
	mods.allow(Modif::Deprecated);
	mods.validate();
	.)
	(. bool isAlias = true; .)
	"Declare"
	[ string_literal
		{ [ comma ] identifier  // TODO: "ANSI" or "CDECL" or "UTF16".
		}
		(. isAlias = false; .)
	]
	( DeclareSignature<isAlias>
	| SyncNewline<s_name>
		{ DeclareSignature<isAlias> Newline }
		"End"
		(. Optional(_Declare); .)
	)
	SyncNewline<s_name>
.
DestructorStatement<Modif &mods> (. ID(L"DestructorStatement", 3) .)
=
	(.
	mods.validate();
	.)
	"Destructor" Newline
	{ Statement }
	"End"
	(. Optional(_Destructor); .)
	Newline
.
DimOrVar (. ID(L"DimOrVar", 3) .)
=
	( "Dim"  (. if (option.Dim_or_Var == TERNARY2) SemErr(L"Must use VAR because of @OPTION"); .)
	| "Var"  (. if (option.Dim_or_Var == TERNARY1) SemErr(L"Must use DIM because of @OPTION"); .)
	)
.
DimStatement<Modif *mods> (. ID(L"DimStatement", 3) .)
=
	(.
	// Permit @Deprecated?
	bool bShared = mods ? mods->allow(Modif::Shared) : false;
	if (mods) mods->validate();
	.)
	DimOrVar
	DeclaratorList<NO_BITS>
	SyncNewline<s_name>
.
DoesClause (. ID(L"DoesClause", 3) .)
=
	"Does" UserType
.
DoStatement (. ID(L"DoStatement", 3) .)
=
	"Do"
	(	// Do...Loop While/Until
		Newline
		[ LoopBody<POSTCONDITIONAL> ]
		"Loop" WhileOrUntil Expression
		SyncNewline<s_name>
	|	// Do While/Until...Loop
		WhileOrUntil Expression
		SyncNewline<s_name>
		[ LoopBody<PRECONDITIONAL> ]
		"Loop" Newline
	)
.
/*E*/
EnclosedArgumentList (. ID(L"EnclosedArgumentList", 3) .)
=
	"("[line_break]
	[ Argument ]
	{ WEAK comma
		[ [line_break] Argument ]
	}
	")"
.
EnclosedExpression (. ID(L"Enclosed", 2) .)
=
	LogicalExpression
.
EnclosedParameterList<int parent> (. ID(L"EnclosedParameterList", 3) .)
=
	(. param_type param(this, parent); .)
	"("[line_break]
	[ FormalParameter<param> { WEAK comma[line_break] FormalParameter<param> } ]
	")"
.
EnumMember (. ID(L"EnumMember", 3) .)
=
	[ "@Deprecated" [ string_literal ] [ line_break ] ]
	identifier
	( "=" Expression
	| (. if (option.Enum_equals) SemErr(L"Enumeration constant must have initializer because of @OPTION"); .)
	)
	SyncNewline<s_name>
.
EnumStatement<Modif &mods> (. ID(L"EnumStatement", 3) .)
=
	(.
	mods.allow(Modif::Deprecated);
	bool bFlags = mods.allow(Modif::Flags);
	bool bOpen = mods.allow(Modif::Open);
	bool bUnique = mods.allow(Modif::Unique);
	mods.validate();
	.)
	"Enum"
	( identifier
	| (. if (bFlags || bOpen || option.Enum_id) {
		const wchar_t *reason = (bFlags) ? L"@FLAGS" : (bOpen) ? L"@OPEN" : L"@OPTION";
		wchar_t *msg = coco_string_create_append(L"Enumeration type must have a name because of ", reason);
		Err(msg);
		coco_string_delete(msg);
	} .)
	)
	( IntegerTypeOrExtension
	| (. if (bFlags || option.Enum_Is) {
		const wchar_t *reason = (bFlags) ? L"@FLAGS" : L"@OPTION";
		wchar_t *msg = coco_string_create_append(L"Enumeration must specify a width because of ", reason);
		Err(msg);
		coco_string_delete(msg);
	} .)
	)
	SyncNewline<s_name>
	{ EnumMember }
	"End"
	(. Optional(_Enum); .)
	Newline
.
EventStatement (. ID(L"EventStatement", 3) .)
=
	(. bool generic = false; .)
	"Event" identifier 
	[ TypeParameterList<_Event> (. generic = true; .) ]
	[ FormalParameterList<_Event> ]
	[ WhereClause<_Event, generic> ]
	SyncNewline<s_name>
.
ExitStatement (. ID(L"ExitStatement", 3) .)
=
	(. int kind = 0; .)
	"Exit"
	( identifier
	| Block<kind> { WEAK comma Block<kind> }
	| "Program" [ EnclosedExpression ]
	)
.
Expression (. ID(L"Expression", 2) .)
=
	ConditionalExpression
	(. if (la->kind == _right_paren) { Get(); SemErr(L"Parentheses do not agree"); } .)
	[ "Tol" real_literal ]
.
/*F*/
FixedPointType<int &tkn> (. ID(L"FixedPointType", 3) .)
=
	(. tkn = la->kind; .)
	( "Fixed64" | "Fixed128" ) [ IF (IsFixedPointArgument()) "(" integer_literal ")" ]
.
FloatingPointType<int &tkn> (. ID(L"FloatingPointType", 3) .)
=
	(. tkn = la->kind; .)
	( "Real32" | "Real64" | "Real" | "Real128" )
.
FormalParameter<param_type &param> (. ID(L"FormalParameter", 3) .)
=
	( FormalParameterModifier<param>
	| (. param.modifier(); .)
	)
	Name
	[ '(' [ Rank ] ')' ]
	[ TypeClause<NO_BITS> ]
	( "=" EnclosedExpression
	| (. if (param.optional() && option.Optional_equals) SemErr(L"Optional parameter must have initializer because of @OPTION"); .)
	)
.
FormalParameterList<int parent> (. ID(L"FormalParameterList", 3) .)
=
	( EnclosedParameterList<parent> | UnenclosedParameterList<parent> )
.
FormalParameterModifier<param_type &param> (. ID(L"FormalParameterModifier", 3) .)
=
	( "ByRef"     (. param.modifier(_ByRef); .)
	| "Optional"  (. param.modifier(_Optional); .)
	)
.
ForStatement (. ID(L"ForStatement", 3) .)
=
	"For"
	( "Each" LoopControlVariable
		"In" InitializationExpression
	| LoopControlVariable
		"=" Expression
		"To" Expression
		[ "Step" Expression ]
	)
	SyncNewline<s_name>
	[ LoopBody<PRECONDITIONAL> ]
	"End"
	(. Optional(_For); .)
	Newline
.
FunctionSignature<Modif &mods, bool &bodied, bool &generic> (. ID(L"FunctionSignature", 3) .)
=
	"Function"
	Name
	(. bool typed_name = (t->kind == _typed_identifier); .)
	(
		[ TypeParameterList<_Function> (. generic = true; .) ]
		[ EnclosedParameterList<_Function> ]
		( ReturnTypeClause
		| (. if (!typed_name) SemErr(L"FUNCTION must have a return type"); .)
		)
		[ WhereClause<_Function, generic> ]
	|
		"Does" QualifiedName<0>
		(. bodied = false; .)
	)
	SyncNewline<s_name>
.
FunctionStatement<Modif &mods> (. ID(L"FunctionStatement", 3) .)
=
	(.
	mods.allow(Modif::Deprecated);
	bool bIterator = mods.allow(Modif::Iterator);
	bool bShared = mods.allow(Modif::Shared);
	mods.validate();

	bool bodied = true;
	bool generic = false;
	.)
	FunctionSignature<mods, bodied, generic>
	[ IF (bodied)
		{ WhereClause<_Function, generic> SyncNewline<s_name> }
		{ Statement }
	"End"
	(. Optional(_Function); .)
		Newline
	]
.
/*G*/
GotoStatement (. ID(L"GotoStatement", 3) .)
=
	"Goto" "Case" ( "Else" | Expression )
.
/*H*/
/*I*/
IdentifierStatement (. ID(L"IdentifierStatement", 3) .)
=
	// Related: SimpleExpression
	( Name [ TypeArgumentList ]
	| "Base"
	| "Self"
	)
	{
		( dot
		| ".?"
		| "?"
		| "??"
		)
		Name [ TypeArgumentList ]
	| EnclosedArgumentList // Also is array subscript.
	}
	[ IF (IsAssignmentOp())
		AssignmentStatement
	|
		CallOrNew<0, nullptr>
	]
.
IfBlockStatement<option_type nThen> (. ID(L"IfBlockStatement", 3) .)
=
	(. bool bElseSeen = false; .)
	(. Optional(_Then, nThen); .)
	SyncNewline<s_name>
	{ Statement }
	{	"Else" (. if (bElseSeen) SemErr(L"ELSE or ELSE IF cannot follow ELSE"); .)
		( "If" Expression (. Optional(_Then); .)
		| (. bElseSeen = true; .)
		)
		SyncNewline<s_name>
		{ Statement }
	}
	"End"
	(. Optional(_If); .)
.
IfStatement (. ID(L"IfStatement", 3) .)
=
	"If" Expression
	(	"Then"
		(
			IfBlockStatement<WITH_THEN>
		|
			(. if (option.If_End) SemErr(L"IF must use block construct because of @OPTION"); .)
			( SimpleStatement | SimpleStatementError )
			[ "Else" ( SimpleStatement | SimpleStatementError ) ]
		)
	|
		IfBlockStatement<WITHOUT_THEN>
	)
	SyncNewline<s_name>
.
InitializationElement (. ID(L"InitializationElement", 3) .)
=
	[ IF (IsUnorderedInit()) IntegerConstant ":=" ]
	InitializationExpression
.
InitializationExpression (. ID(L"InitializationExpression", 3) .)
=
	( Expression
	| "{"[line_break] InitializationElement { WEAK comma[line_break] InitializationElement } "}"
	  // Permit isolated right brace.
	  [ IF (la->kind == _line_break && scanner->Peek()->kind == _right_brace) line_break ]
	)
.
IntegerConstant (. ID(L"IntegerConstant", 3) .)
=
	( char_literal | integer_constant | integer_literal )
.
IntegerType<int &tkn> (. ID(L"IntegerType", 3) .)
=
	(. tkn = la->kind; .)
	( "Int8"  | "Int16"  | "Int32"  | "Int"  | "Int64"  | "Int128"
	| "UInt8" | "UInt16" | "UInt32" | "UInt" | "UInt64" | "UInt128"
	)
.
IntegerTypeOrExtension (. ID(L"IntegerTypeOrExtension", 3) .)
=
	(. int tkn = 0; .)
	"Is" ( identifier | IntegerType<tkn> )
.
InUnitClause (. ID(L"InUnitClause", 3) .)
=
	"In" UnitOfMeasure
.
IsExpression (. ID(L"IsExpression", 2) .)
=
	"Is" ( SimpleExpression | "Object" )
.
/*J*/
/*K*/
/*L*/
LogicalExpression (. ID(L"Logical", 2) .)
=
	ComparisonExpression { LogicalOperator ComparisonExpression }
.
LogicalOperator (. ID(L"LogicalOperator", 3) .)
=
	( "And" [ "Then" ]
	| "Or" [ "Else" ]
	| "Xor"
	)
.
LoopControlVariable (. ID(L"LoopControlVariable", 3) .)
=
	( ObjectName [ AsTypeClause<NO_BITS> ]
	| typed_identifier
	)
.
LoopBody<bool isPreconditional> (. ID(L"LoopBody", 3) .)
=
	(
		Statement { Statement }
	|
		(. when_map whens; .)
		"Begin"
		(. int begin_l = t->line, begin_c = t->col; .)
		[
			identifier
			(.
			std::wstring id(t->val);
			std::transform(id.begin(), id.end(), id.begin(), std::towupper);
			whens[id]++;
			.)
			{ WEAK comma
				identifier
				(.
				std::wstring id(t->val);
				std::transform(id.begin(), id.end(), id.begin(), std::towupper);
				if (++whens[id] == 2) {
					SemErr(L"BEGIN cannot have two of the same label");
					whens[id] = 1;
				}
				.)
			}
		]
		SyncNewline<s_name>
		{ Statement }
		WhenStatement<isPreconditional, whens>
		{ WhenStatement<isPreconditional, whens> }
		// TODO: if @Option When id Begin id, make sure labels agree with whens.
	)
.
/*M*/
MethodStatement<Modif &mods> (. ID(L"MethodStatement", 3) .)
=
	(.
	bool bAbstract = mods.allow(Modif::Abstract);
	mods.allow(Modif::Deprecated);
	bool bIterator = mods.allow(Modif::Iterator);
	bool bOpen     = mods.allow(Modif::Open);
	bool bOverride = mods.allow(Modif::Override);
	bool bShared   = mods.allow(Modif::Shared);
	mods.validate();
	.)
	MethodSignature<mods>
	{ Statement }
	"End"
	(. Optional(_Method); .)
	Newline
.
MethodSignature<Modif &mods> (. ID(L"MethodSignature", 3) .)
=
	"Method" Name
	[ EnclosedParameterList<_Method> [ ReturnTypeClause ]
	| UnenclosedParameterList<_Method>
	| ReturnTypeClause
	]
	SyncNewline<s_name>
.
Modifier<int &m> (. ID(L"Modifier", 3) .)
=
	( "@Abstract"    (. m = Modif::Abstract; .)
	| "@Backed"      (. m = Modif::Backed; .)
	| "@Deprecated" [ string_literal ]
	                 (. m = Modif::Deprecated; .)
	| "@Flags"       (. m = Modif::Flags; .)
	| "@Iterator"    (. m = Modif::Iterator; .)
	| "@Open"        (. m = Modif::Open; .)
	| "@Override"    (. m = Modif::Override; .)
	| "@ReadOnly"    (. m = Modif::ReadOnly; .)
	| "@Shared"      (. m = Modif::Shared; .)
	| "@SI"          (. m = Modif::SI; .)
	| "@Unique"      (. m = Modif::Unique; .)
	| "@WriteOnly"   (. m = Modif::WriteOnly; .)
	)
	[ line_break ]
.
ModifiersClause<Modif &mods> (. ID(L"ModifiersClause", 3) .)
=
	(. int m; .)
	Modifier<m>  (. mods.add(m); .)
	{ Modifier<m>  (. mods.add(m); .) 
	}
.
Module (. ID(L"Module", 3) .)
=
	(. bool bProcEntry = false; .)
	[ Newline ]
	(
		"Program"
		[ "=" (. bProcEntry = true; .) ]
		identifier
	|
		"Library"
		QualifiedName<_identifier>
	)
	SyncNewline<s_name>
	{ WhereStatement }
	{ RequireStatement }
	{
		ModuleMember
	|
		ModuleStatement<bProcEntry>
	}
.
ModuleMember (. ID(L"ModuleMember", 3) .)
=
	(. Modif mods(this); .)
	[ ModifiersClause<mods> ]
	( BaseUnitStatement<mods>
	| ClassStatement<mods>
	| ConstStatement<mods>
	| DeclareStatement<mods>
	| EnumStatement<mods>
	| FunctionStatement<mods>
	| MethodStatement<mods>
	| NamespaceStatement<mods>
	| ObjectStatement<&mods>
	| PropertyStatement<mods>
	| StructStatement<mods>
	| SubStatement<mods>
	| TraitStatement<mods>
	| UnitStatement<mods>
	)
.
ModuleStatement<bool bProcEntry> (. ID(L"ModuleStatement", 3) .)
=
	(. if (bProcEntry) Warn(L"Executable statements at module level ignored when entry point is a procedure"); .)
	Statement
.
MultiplicativeExpression (. ID(L"Multiplicative", 2) .)
=
	PowerExpression { MultiplicativeOperator PowerExpression }
.
MultiplicativeOperator (. ID(L"MultiplicativeOperator", 3) .)
=
	( '*' | '/' | "Mod" | "Rem" )
.
/*N*/
Name (. ID(L"Name", 3) .)
=
	( identifier
	| nullable_identifier
	| typed_identifier
	)
.
NamespaceStatement<Modif &mods> (. ID(L"NamespaceStatement", 3) .)
=
	(.
	mods.allow(Modif::Deprecated);
	mods.validate();
	.)
	"Namespace" QualifiedName<_identifier> SyncNewline<s_name>
	{ ModuleMember }
	"End"
	(. Optional(_Namespace); .)
	Newline
.
NewBlockStatement (. ID(L"NewBlockStatement", 3) .)
=
	(.
	bool bInitExpr = false;
	wchar_t *type_name = nullptr;
	.)
///	( "New" (. bNew = true; .)
///	| (. if (option.New) Err(L"NEW is mandatory  because of @OPTION"); .)
///	)
	"Begin"
		[ "Call" QualifiedName<0>
			[ InitializationExpression (. bInitExpr = true; .) ]
		| UserType
		]
		SyncNewline<s_name>
		[	NewMember (. if (bInitExpr) SemErr(L"Expected END after initialization expression"); .)
			{ NewMember }
		]
		"End"
	[ "New" | identifier ] // TODO: test type_name
	(. coco_string_delete(type_name); .)
.
NewMember (. ID(L"NewMember", 3) .)
=
	[ Newline ]
	( NewStatement<nullptr>
	| ObjectStatement<nullptr>
	| dot IdentifierStatement SyncNewline<s_name>
	| ArgumentList SyncNewline<s_name>
	)
.
NewStatement<Modif *mods> (. ID(L"NewStatement", 3) .)
=
	"New" UserType CallOrNew<_New, mods>
	SyncNewline<s_name>
.
Newline (. ID(L"Newline", 3) .)
=
	line_break { line_break }
.
NullCoalescingExpression (. ID(L"NullCoalescing", 2) .)
=
	TypeExpression [ "|?" NullCoalescingExpression ]
.
/*O*/
ObjectName (. ID(L"ObjectName", 3) .)
=
	( identifier
	| nullable_identifier
	)
.
ObjectStatement<Modif *mods> (. ID(L"ObjectStatement", 3) .)
=
	(.
	mods ? mods->allow(Modif::Deprecated) : false;
	bool bShared = mods ? mods->allow(Modif::Shared) : false;
	if (mods) mods->validate();
	.)
	"Object" ObjectName
	[ "Is" UserType ]
	{ DoesClause }
	SyncNewline<s_name>
	{ ClassOrObjectMember<_Object> }
	"End"
	(. Optional(_Object); .)
	Newline
.
/*P*/
PassableType (. ID(L"PassableType", 3) .)
=
	( PrimitiveType<NO_BITS> | UserType )
	[ Rank ]
.
PowerExpression (. ID(L"Power", 2) .)
=
	BitShiftExpression [ "^" PowerExpression ]
.
PrimaryExpression (. ID(L"Primary", 2) .)
=
	( char_literal
	| integer_constant
	| ( integer_literal | real_literal ) [ IF (IsUnit()) UnitExpression ]
	| fixed_literal
	| DateTimeExpression
	| StringExpression
	| [ "Class" | "Trait" | "Sub" ]
		Name [ TypeArgumentList ]
		{
			// Syntactic sugar for argumentless proc call.
			// Lets one do "proc?" or "proc1?proc2?proc3?" instead of
			// "proc()" or "proc1().proc2().proc3()", respectively.

			question
			[ /// IF (IsIdentifier(la->kind))
				Name [ TypeArgumentList ]
			]
		}
	| PrimitiveType<YES_BITS>
	| "(" EnclosedExpression ")"
	| "Base"
	| "Self"
	| "#Null"
	| malformed_char_literal     (. SemErr(L"Bad character constant"); .)
	| malformed_fixed_literal    (. SemErr(L"Bad fixed constant"); .)
	| malformed_integer_literal  (. SemErr(L"Bad integer constant"); .)
	| malformed_real_literal     (. SemErr(L"Bad real constant"); .)
	| malformed_string_literal   (. SemErr(L"Bad string constant"); .)
	)
.
PrimitiveType<bool bBits> (. ID(L"PrimitiveType", 3) .)
=
	(. int kind = 0; .)
	( "Boolean" | "Char" | "DateTime"
	| "SafeString" | "String"  //TODO: Limit on where can use SafeString.
	| IntegerType<kind>
	| FloatingPointType<kind>
	| FixedPointType<kind>
	| BitFieldType<kind>  (. if (!bBits) SemErr(L"Bit field not permitted here"); .)
	)
.
///PropertyOrCall (. ID(PropertyOrCall) .)
///=
///	Name
///	[ IF (IsCall()) EnclosedArgumentList ]
///.
PropertySignature<Modif &mods> (. ID(L"PropertySignature", 3) .)
=
	(. bool explicit_array = false; .)
	"Property"
	[ DimOrVar (. explicit_array = true; .) ]
	( IF (IsPropertySelf())
		( typed_identifier | "Self" ) (. if (explicit_array) SemErr(L"Cannot use DIM or VAR with SELF"); .)
		EnclosedParameterList<_Property>
	| IF (!explicit_array && IsPropertyWithParam())
		Name EnclosedParameterList<_Property>
	| DeclaratorList<NO_BITS>
	)
	[ "Does" identifier dot identifier ]
	SyncNewline<s_name>
.
PropertyStatement<Modif &mods> (. ID(L"PropertyStatement", 3) .)
=
	(.
	bool bAbstract  = mods.allow(Modif::Abstract);
	bool bBacked    = mods.allow(Modif::Backed);
	mods.allow(Modif::Deprecated);
	bool bIterator  = mods.allow(Modif::Iterator);
	bool bOpen      = mods.allow(Modif::Open);
	bool bOverride  = mods.allow(Modif::Override);
	bool bReadOnly  = mods.allow(Modif::ReadOnly);
	bool bShared    = mods.allow(Modif::Shared);
	bool bWriteOnly = mods.allow(Modif::WriteOnly);
	mods.validate();
	.)
	PropertySignature<mods>
	[ IF (la->kind == _Get || la->kind == _Set)
		[	"Get" Newline
			{ Statement }
		]
		[	"Set" [ FormalParameterList<_Set> ] SyncNewline<s_name>  //TODO: only one param
			{ Statement }
		]
		"End"
	(. Optional(_Property); .)
		Newline
	]
.
/*Q*/
QualifiedName<int limit> (. ID(L"QualifiedName", 3) .)
=
	(. const wchar_t *msg = L"Namespace or type name expected"; .)
	Name
		(. if ((limit == _identifier || la->kind == _dot) && t->kind != _identifier) SemErr(msg); .)
	{ dot Name  
		(. if (limit == _identifier && t->kind != _identifier) SemErr(msg); .)
	}
.
/*R*/
RaiseStatement (. ID(L"RaiseStatement", 3) .)
=
	"Raise"
	( "Event" Name [ ArgumentList ]
	| Expression
	)
.
Rank (. ID(L"Rank", 3) .)
=
	"*" integer_literal
.
ReDimClause (. ID(L"ReDimClause", 3) .)
=
	QualifiedName<0>
	"(" EnclosedExpression
	{ comma EnclosedExpression }
	")"
.
ReDimStatement (. ID(L"ReDimStatement", 3) .)
=
	"ReDim" ReDimClause
	{ comma ReDimClause }
.
RequireComparison (. ID(L"RequireComparison", 3) .)
=
	// TODO: strings can only be "=" or "<>".
	( [ version_literal ( "<" | "<=" ) ]  // Eg 1.0.0 <= version < 2.0.0
		identifier
		ComparisonOperator ( string_literal | version_literal )
	| "(" RequireLogic ")"
	)
.
RequireLogic (. ID(L"RequireLogic", 3) .)
=
	RequireComparison
	{ ( "And" | "Or" ) RequireComparison }
.
RequireStatement (. ID(L"RequireStatement", 3) .)
=
	"Require"
	QualifiedName<_identifier> [ "As" identifier ]
	( { comma QualifiedName<_identifier> [ "As" identifier ] }
	| "Where" RequireLogic
	)
	SyncNewline<s_name>
.
ReturnStatement (. ID(L"ReturnStatement", 3) .)
=
	"Return" [ Expression ]
.
ReturnTypeClause (. ID(L"ReturnTypeClause", 3) .)
=
	( AsTypeClause<NO_BITS>
	| InUnitClause
	)
.
/*S*/
SelectStatement (. ID(L"SelectStatement", 3) .)
=
	(. case_type clause = CASE_ZERO; .)
	"Select"
	(. Optional(_Case); .)
	Expression
	SyncNewline<s_name>
	{ CaseClause<clause> }
	"End"
		(. if (clause == CASE_ZERO) SemErr(L"SELECT must have a minimum of one CASE"); .)
		(. if (option.Select_Else == SELECT_ELSE && clause != CASE_ELSE) SemErr(L"SELECT must have CASE ELSE because of @OPTION"); .)
	(. Optional(_Select); .)
	Newline
.
SimpleExpression (. ID(L"Simple", 2) .)
=
	// Related: IdentifierStatement
	PrimaryExpression
	{
		( dot   // Member access
		| ".?"  // Null-conditional member access (eg "#obj.?proc?")
		| "??"  // Method call with null-conditional member access (eg "#proc1??proc2?")
		)
		Name [ TypeArgumentList ]
	| "!" Name  // Dictionary access
	| EnclosedArgumentList
	}
.
SimpleStatement (. ID(L"SimpleStatement", 3) .)
=
	( CallStatement
	| GotoStatement
	| ExitStatement
	| IdentifierStatement
	| RaiseStatement
	| ReDimStatement
	| ReturnStatement
	| YieldStatement
	)
.
SimpleStatementError (. ID(L"SimpleStatementError", 3) .)
=
	(. Err(la->line, la->col, L"This statement not permitted with one-line IF...ELSE"); .)
	BlockStatement
.
Statement (. ID(L"Statement", 3) .)
=
	( BlockStatement
	| SimpleStatement SyncNewline<s_name>
	)
.
StringExpression (. ID(L"String", 2) .)
=
	( string_literal | string_constant )
	{ IF (la->kind == _string_constant || la->kind == _string_literal || la->kind == _slash || la->kind == _backslash)
		[
			"/"
			(. if (option.String_bk_slash == TERNARY1) SemErr(L"Must use backslash because of @OPTION"); .)
		|
			"\\"
			(. if (option.String_bk_slash == TERNARY2) SemErr(L"Must use slash because of @OPTION"); .)
		]
		( string_literal | string_constant )
	}
.
StructStatement<Modif &mods> (. ID(L"StructStatement", 3) .)
=
	(.
	mods.allow(Modif::Deprecated);
	mods.validate();

	bool generic = false;
	.)
	"Struct" identifier
	[ TypeParameterList<_Struct> (. generic = true; .) ]
	[ "Is" ValueType ]
	{ DoesClause }
	[ WhereClause<_Struct, generic> ]
	SyncNewline<s_name>
	{ WhereClause<_Struct, generic> SyncNewline<s_name> }
	{ StructState }
	{ StructProcedure }
	"End"
	(. Optional(_Struct); .)
	Newline
.
StructProcedure (. ID(L"StructProcedure", 3) .)
=
	(. Modif mods(this); .)
	( ConstructorStatement<mods>
	| FunctionStatement<mods>
	| MethodStatement<mods>
	| PropertyStatement<mods>
	| SubStatement<mods>
	|
		(. Err(la->line, la->col, L"STRUCT cannot have DESTRUCTOR"); .)
		DestructorStatement<mods>
	)
.
StructState (. ID(L"StructState", 3) .)
=
	(. Modif mods(this); .)
	[ ModifiersClause<mods> ]
	(
		(.
		mods.allow(Modif::Deprecated);
		mods.allow(Modif::Shared);
		mods.validate();
		.)
		[ DimOrVar ] DeclaratorList<YES_BITS>
		SyncNewline<s_name>
	| ConstStatement<mods>
	| EnumStatement<mods>
	| EventStatement
	| StructStatement<mods>
	|
		(. Err(la->line, la->col, L"STRUCT cannot have CLASS member"); .)
		ClassStatement<mods>
	)
.
SubSignature<bool &generic> (. ID(L"SubSignature", 3) .)
=
	"Sub"
	Name
	(. bool return_typed = (t->kind == _typed_identifier); .)
	[ TypeParameterList<_Sub> (. generic = true; .) ]
	[
		EnclosedParameterList<_Sub>
		[ ReturnTypeClause (. return_typed = true; .) ]
	|
		UnenclosedParameterList<_Sub>
	|
		ReturnTypeClause (. return_typed = true; .)
	]
	[
		"Handles"
		(. if (return_typed) SemErr(L"Event handlers cannot have a return type"); .)
		QualifiedName<_identifier>
	]
	[ WhereClause<_Sub, generic> ]
	SyncNewline<s_name>
.
SubStatement<Modif &mods> (. ID(L"SubStatement", 3) .)
=
	(.
	mods.allow(Modif::Deprecated);
	bool bIterator = mods.allow(Modif::Iterator);
	bool bShared   = mods.allow(Modif::Shared);
	mods.validate();

	bool generic = false;
	.)
	SubSignature<generic>
	{ WhereClause<_Sub, generic> SyncNewline<s_name> }
	{ Statement }
	"End"
	(. Optional(_Sub); .)
	Newline
.
SyncNewline<const wchar_t *name> (. ID(L"SyncNewline", 3) .)
=
	(.
	wchar_t *msg = NULL;
	while (!(la->kind == _EOF || la->kind == _line_break)) {
		if (!msg) msg = coco_string_create_append(L"This symbol not expected in ", name);
		Err(msg);
		Get();
	}
	coco_string_delete(msg);
	.)
	line_break { line_break }
.
/*T*/
TraitMember (. ID(L"TraitMember", 3) .)
=
	(. Modif mods(this); .)
	[ ModifiersClause<mods> ]
	( DimStatement<&mods>
	| FunctionStatement<mods>
	| MethodStatement<mods>
	| PropertyStatement<mods>
	| StructStatement<mods>
	| SubStatement<mods>
	)
.
TraitStatement<Modif &mods> (. ID(L"TraitStatement", 3) .)
=
	(.
	bool bAbstract = mods.allow(Modif::Abstract);
	mods.allow(Modif::Deprecated);
	mods.validate();

	bool generic = false;
	.)
	"Trait" identifier
	[ TypeParameterList<_Trait> (. generic = true; .) ]
	{ DoesClause }
	[ WhereClause<_Trait, generic> ]
	SyncNewline<s_name>
	{ WhereClause<_Trait, generic> SyncNewline<s_name> }
	{ TraitMember }
	"End"
	(. Optional(_Trait); .)
	Newline
.
TryStatement (. ID(L"TryStatement", 3) .)
=
	"Try" Newline
	{ Statement }
	{ CatchClause }
	[	"Finally" Newline
		{ Statement }
	]
	"End"
	(. Optional(_Try); .)
	Newline
.
TypeArgumentList (. ID(L"TypeArgumentList", 3) .)
=
	'[' PassableType { WEAK comma PassableType } ']'
.
TypeClause<bool bBits> (. ID(L"TypeClause", 3) .)
=
	( AsTypeClause<bBits>
	| InUnitClause
	)
.
TypeConversion (. ID(L"TypeConversion", 2) .)
=
	( "As" ConvertibleType
	| InUnitClause
	)
.
TypeExpression (. ID(L"Type", 2) .)
=
	ConcatenationExpression [ IsExpression | TypeConversion ]
.
TypeParameter<int parent> (. ID(L"TypeParameter", 3) .)
=
	[
		( "In" | "Out" )
		(. if (parent != _Event && parent != _Trait) SemErr(L"IN and OUT are permitted only with EVENT and TRAIT"); .)
	]
	identifier
.
TypeParameterList<int parent> (. ID(L"TypeParameterList", 3) .)
=
	"["
	TypeParameter<parent>
	{ WEAK comma TypeParameter<parent> }
	"]"
.
/*U*/
UnaryExpression (. ID(L"Unary", 2) .)
=
	{ UnaryOperator } SimpleExpression
.
UnaryOperator (. ID(L"UnaryOperator", 3) .)
=
	( '+' | '-' | "Not" )
.
///UnenclosedArgument (. ID(L"UnenclosedArgument", 3) .)
///=
///	( line_break Argument
///	| Argument
///	)
///.
UnenclosedArgumentList (. ID(L"UnenclosedArgumentList", 3) .)
=
	( Argument
	| comma (. SemErr(L"Argument list cannot start with comma"); .)
	)
	{ WEAK comma
		( [line_break] Argument
		| (. /* TODO: empty arg */ .)
		)
	}
	(. if (t->kind == _comma) SemErr(L"Argument list cannot end with comma"); .)
.
UnenclosedParameterList<int parent> (. ID(L"UnenclosedParameterList", 3) .)
=
	(. param_type param(this, parent); .)
	FormalParameter<param> { WEAK comma[line_break] FormalParameter<param> }
.
UnitAlias (. ID(L"UnitAlias", 3) .)
=
	(. int number = -1; .)
	[
		integer_literal  // Grammatical number: 1 = singular, 2 = plural, 0 = zero & singular.
		(. if (t->val[0] >= L'0' && t->val[0] <= L'2' && t->val[1] == L'\0') number = t->val[0] - L'0';
		else SemErr(L"number must be 0, 1, or 2"); .)
	]
	identifier 
	[
		( "+" | "-" ) // Plurals by "unit+suffix" or "prefix-unit".
		(. if (number > 0) SemErr(L"Name cannot have a plural part after 1 or 2"); .)
		identifier
	]
.
UnitExpression (. ID(L"Unit", 2) .)
=
	UnitOfMeasure  { ( integer_literal | real_literal ) UnitOfMeasure  }
.
UnitOfMeasure (. ID(L"UnitOfMeasure", 3) .)
=
	( identifier
	| "(" identifier { [ "*" | "/" ] identifier } ")"
	)
.
UnitParameter (. ID(L"UnitParameter", 3) .)
=
	"(" identifier InUnitClause ")"
.
UnitStatement<Modif &mods> (. ID(L"UnitStatement", 3) .)
=
	(.
	mods.allow(Modif::Deprecated);
	bool bSI = mods.allow(Modif::SI);
	mods.validate();
	.)
	"Unit"
	UnitAlias { UnitAlias }
	[ UnitParameter "=" AdditiveExpression
	| "=" AdditiveExpression
	]
	SyncNewline<s_name>
	// TODO: Think about block construct to do range tests, for example:
	//  Unit Kelvin K
	//  Set value
	//      If value < 0.0 Then Raise RangeError
	//  End Unit
.
UserType (. ID(L"UserType", 3) .)
=
	QualifiedName<_identifier> [ TypeArgumentList ]
.
/*V*/
ValueType (. ID(L"ValueType", 3) .)
=
	( PrimitiveType<NO_BITS> | UserType )
.
/*W*/
WhenStatement<bool isPreconditional, when_map &whens> (. ID(L"WhenStatement", 3) .)
=
	"When"
	( identifier
	| "Each"
		(. if (option.When_Each_Else == TERNARY2) SemErr(L"Must use ELSE because of @OPTION"); .)
	| "Else" // Equivalent to "Each".
		(. if (option.When_Each_Else == TERNARY1) SemErr(L"Must use EACH because of @OPTION"); .)
	)
	(.
	int kind = t->kind;
	// Change label to upper case.
	wchar_t *val = (t->kind != _Else) ? t->val : L"EACH";
	std::wstring id(val);
	std::transform(id.begin(), id.end(), id.begin(), std::towupper);
	switch ((whens[id] += 2)) {
	case 2: // Label not in Begin.
		if (option.When_id_Begin_id && kind == _identifier) {
			SemErr(L"WHEN label must be declared with BEGIN because of @OPTION");
		}
		break;
	case 3: // Label in Begin and When.
		break;
	default: // Duplicate.
		if (kind == _identifier) SemErr(L"Loop cannot have more than one WHEN with the same label");
		else SemErr(L"Loop cannot have more than one WHEN EACH or WHEN ELSE");
		break;
	}
	.)
	Newline
	{ Statement }
.
WhereClause<int block, bool generic> (. ID(L"WhereClause", 3) .)
=
	"Where"
	(. if (!generic) SemErr(L"Declared element is missing generic type parameter(s)"); .)
	Constraint<block> { WEAK comma[line_break] Constraint<block> }
.
WhereStatement (. ID(L"WhereStatement", 3) .)
=
	"Where"
	identifier '='
	( DateTimeExpression | string_literal | version_literal )
	SyncNewline<s_name>
.
WhileOrUntil (. ID(L"WhileOrUntil", 3) .)
=
	( "While"
	| "Until"
	)
.
WhileStatement (. ID(L"WhileStatement", 3) .)
=
	"While" Expression SyncNewline<s_name>
	[ LoopBody<PRECONDITIONAL> ]
	"End"
	(. Optional(_While); .)
	Newline
.
/*X*/
/*Y*/
YieldStatement (. ID(L"YieldStatement", 3) .)
=
	"Yield" Expression
.
/*Z*/

END ViviFire.
